/* tslint:disable */
/* eslint-disable */
/**
 * FLECS Daemon API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Additional info
 * @export
 * @interface AdditionalInfo
 */
export interface AdditionalInfo {
    /**
     * 
     * @type {string}
     * @memberof AdditionalInfo
     */
    'additionalInfo': string;
}
/**
 * 
 * @export
 * @interface AppEditor
 */
export interface AppEditor {
    /**
     * 
     * @type {string}
     * @memberof AppEditor
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof AppEditor
     */
    'port': number;
    /**
     * 
     * @type {boolean}
     * @memberof AppEditor
     */
    'supportsReverseProxy'?: boolean;
}
/**
 * Instance of an App
 * @export
 * @interface AppInstance
 */
export interface AppInstance {
    /**
     * 
     * @type {string}
     * @memberof AppInstance
     */
    'instanceId': string;
    /**
     * Instance name
     * @type {string}
     * @memberof AppInstance
     */
    'instanceName': string;
    /**
     * 
     * @type {AppKey}
     * @memberof AppInstance
     */
    'appKey': AppKey;
    /**
     * 
     * @type {InstanceStatus}
     * @memberof AppInstance
     */
    'status': InstanceStatus;
    /**
     * 
     * @type {InstanceStatus}
     * @memberof AppInstance
     */
    'desired': InstanceStatus;
    /**
     * 
     * @type {Array<InstanceEditor>}
     * @memberof AppInstance
     */
    'editors'?: Array<InstanceEditor>;
}


/**
 * 
 * @export
 * @interface AppKey
 */
export interface AppKey {
    /**
     * 
     * @type {string}
     * @memberof AppKey
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AppKey
     */
    'version': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AppStatus = {
    NotInstalled: 'not installed',
    ManifestDownloaded: 'manifest downloaded',
    TokenAcquired: 'token acquired',
    ImageDownloaded: 'image downloaded',
    Installed: 'installed',
    Removed: 'removed',
    Purged: 'purged',
    Orphaned: 'orphaned',
    Unknown: 'unknown'
} as const;

export type AppStatus = typeof AppStatus[keyof typeof AppStatus];


/**
 * 
 * @export
 * @interface AppsInstallPostRequest
 */
export interface AppsInstallPostRequest {
    /**
     * 
     * @type {AppKey}
     * @memberof AppsInstallPostRequest
     */
    'appKey': AppKey;
}
/**
 * 
 * @export
 * @interface AppsSideloadPostRequest
 */
export interface AppsSideloadPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AppsSideloadPostRequest
     */
    'manifest': string;
}
/**
 * 
 * @export
 * @interface AuthResponseData
 */
export interface AuthResponseData {
    /**
     * 
     * @type {User}
     * @memberof AuthResponseData
     */
    'user': User;
    /**
     * 
     * @type {Jwt}
     * @memberof AuthResponseData
     */
    'jwt': Jwt;
    /**
     * 
     * @type {FeatureFlags}
     * @memberof AuthResponseData
     */
    'feature_flags': FeatureFlags;
}
/**
 * 
 * @export
 * @interface BindMount
 */
export interface BindMount {
    /**
     * 
     * @type {string}
     * @memberof BindMount
     */
    'container': string;
    /**
     * 
     * @type {string}
     * @memberof BindMount
     */
    'host': string;
}
/**
 * 
 * @export
 * @interface DeploymentNetwork
 */
export interface DeploymentNetwork {
    /**
     * 
     * @type {string}
     * @memberof DeploymentNetwork
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentNetwork
     */
    'driver'?: string;
    /**
     * 
     * @type {Network}
     * @memberof DeploymentNetwork
     */
    'subnet'?: Network;
    /**
     * 
     * @type {string}
     * @memberof DeploymentNetwork
     */
    'parent'?: string;
}
/**
 * 
 * @export
 * @interface DeploymentsDeploymentIdNetworksNetworkIdDhcpIpv4Post200Response
 */
export interface DeploymentsDeploymentIdNetworksNetworkIdDhcpIpv4Post200Response {
    /**
     * 
     * @type {string}
     * @memberof DeploymentsDeploymentIdNetworksNetworkIdDhcpIpv4Post200Response
     */
    'ipv4_address': string;
}
/**
 * 
 * @export
 * @interface DeviceLicenseActivationStatusGet200Response
 */
export interface DeviceLicenseActivationStatusGet200Response {
    /**
     * 
     * @type {boolean}
     * @memberof DeviceLicenseActivationStatusGet200Response
     */
    'isValid': boolean;
}
/**
 * 
 * @export
 * @interface DeviceLicenseInfoGet200Response
 */
export interface DeviceLicenseInfoGet200Response {
    /**
     * 
     * @type {string}
     * @memberof DeviceLicenseInfoGet200Response
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof DeviceLicenseInfoGet200Response
     */
    'license'?: string;
    /**
     * 
     * @type {SessionId}
     * @memberof DeviceLicenseInfoGet200Response
     */
    'sessionId'?: SessionId;
}
/**
 * 
 * @export
 * @interface Devices
 */
export interface Devices {
    /**
     * 
     * @type {Array<UsbDevice>}
     * @memberof Devices
     */
    'usb'?: Array<UsbDevice>;
}
/**
 * Device Onboarding Service Manifest
 * @export
 * @interface Dosschema
 */
export interface Dosschema {
    /**
     * 
     * @type {string}
     * @memberof Dosschema
     */
    '_schemaVersion': string;
    /**
     * 
     * @type {string}
     * @memberof Dosschema
     */
    'time': string;
    /**
     * 
     * @type {Set<DosschemaAppsInner>}
     * @memberof Dosschema
     */
    'apps': Set<DosschemaAppsInner>;
}
/**
 * 
 * @export
 * @interface DosschemaAppsInner
 */
export interface DosschemaAppsInner {
    /**
     * 
     * @type {string}
     * @memberof DosschemaAppsInner
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof DosschemaAppsInner
     */
    'version'?: string;
}
/**
 * 
 * @export
 * @interface ExportRequest
 */
export interface ExportRequest {
    /**
     * 
     * @type {Array<AppKey>}
     * @memberof ExportRequest
     */
    'apps': Array<AppKey>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ExportRequest
     */
    'instances'?: Array<string>;
}
/**
 * 
 * @export
 * @interface FeatureFlags
 */
export interface FeatureFlags {
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'isVendor': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureFlags
     */
    'isWhitelabeled': boolean;
}
/**
 * 
 * @export
 * @interface InstalledApp
 */
export interface InstalledApp {
    /**
     * 
     * @type {AppKey}
     * @memberof InstalledApp
     */
    'appKey': AppKey;
    /**
     * 
     * @type {AppStatus}
     * @memberof InstalledApp
     */
    'status': AppStatus;
    /**
     * 
     * @type {AppStatus}
     * @memberof InstalledApp
     */
    'desired': AppStatus;
    /**
     * 
     * @type {number}
     * @memberof InstalledApp
     */
    'installedSize': number;
    /**
     * 
     * @type {boolean}
     * @memberof InstalledApp
     */
    'multiInstance': boolean;
    /**
     * 
     * @type {Array<AppEditor>}
     * @memberof InstalledApp
     */
    'editors': Array<AppEditor>;
}


/**
 * 
 * @export
 * @interface InstanceConfig
 */
export interface InstanceConfig {
    /**
     * 
     * @type {Array<InstanceConfigNetworkAdapter>}
     * @memberof InstanceConfig
     */
    'networkAdapters': Array<InstanceConfigNetworkAdapter>;
    /**
     * 
     * @type {InstanceConfigDevices}
     * @memberof InstanceConfig
     */
    'devices': InstanceConfigDevices;
}
/**
 * 
 * @export
 * @interface InstanceConfigDevices
 */
export interface InstanceConfigDevices {
    /**
     * 
     * @type {Array<InstanceConfigUsbDevice>}
     * @memberof InstanceConfigDevices
     */
    'usb': Array<InstanceConfigUsbDevice>;
}
/**
 * 
 * @export
 * @interface InstanceConfigNetwork
 */
export interface InstanceConfigNetwork {
    /**
     * 
     * @type {string}
     * @memberof InstanceConfigNetwork
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof InstanceConfigNetwork
     */
    'ipAddress': string;
}
/**
 * 
 * @export
 * @interface InstanceConfigNetworkAdapter
 */
export interface InstanceConfigNetworkAdapter {
    /**
     * 
     * @type {string}
     * @memberof InstanceConfigNetworkAdapter
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceConfigNetworkAdapter
     */
    'active': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceConfigNetworkAdapter
     */
    'connected': boolean;
    /**
     * 
     * @type {string}
     * @memberof InstanceConfigNetworkAdapter
     */
    'ipAddress'?: string;
    /**
     * 
     * @type {string}
     * @memberof InstanceConfigNetworkAdapter
     */
    'subnetMask'?: string;
    /**
     * 
     * @type {string}
     * @memberof InstanceConfigNetworkAdapter
     */
    'gateway'?: string;
}
/**
 * 
 * @export
 * @interface InstanceConfigUsbDevice
 */
export interface InstanceConfigUsbDevice {
    /**
     * 
     * @type {string}
     * @memberof InstanceConfigUsbDevice
     */
    'port': string;
    /**
     * 
     * @type {string}
     * @memberof InstanceConfigUsbDevice
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof InstanceConfigUsbDevice
     */
    'pid'?: number;
    /**
     * 
     * @type {string}
     * @memberof InstanceConfigUsbDevice
     */
    'vendor'?: string;
    /**
     * 
     * @type {number}
     * @memberof InstanceConfigUsbDevice
     */
    'vid'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof InstanceConfigUsbDevice
     */
    'device_connected': boolean;
}
/**
 * 
 * @export
 * @interface InstanceDetailConfigFile
 */
export interface InstanceDetailConfigFile {
    /**
     * 
     * @type {string}
     * @memberof InstanceDetailConfigFile
     */
    'container': string;
    /**
     * 
     * @type {string}
     * @memberof InstanceDetailConfigFile
     */
    'host': string;
}
/**
 * Bind mounts of an instance
 * @export
 * @interface InstanceDetailMounts
 */
export interface InstanceDetailMounts {
    /**
     * 
     * @type {Array<InstanceDetailMountsMountsInner>}
     * @memberof InstanceDetailMounts
     */
    'mounts': Array<InstanceDetailMountsMountsInner>;
}
/**
 * 
 * @export
 * @interface InstanceDetailMountsMountsInner
 */
export interface InstanceDetailMountsMountsInner {
    /**
     * 
     * @type {string}
     * @memberof InstanceDetailMountsMountsInner
     */
    'container': string;
    /**
     * 
     * @type {string}
     * @memberof InstanceDetailMountsMountsInner
     */
    'host': string;
}
/**
 * 
 * @export
 * @interface InstanceDetailPort
 */
export interface InstanceDetailPort {
    /**
     * 
     * @type {string}
     * @memberof InstanceDetailPort
     */
    'container': string;
    /**
     * 
     * @type {string}
     * @memberof InstanceDetailPort
     */
    'host': string;
}
/**
 * 
 * @export
 * @interface InstanceDetailVolume
 */
export interface InstanceDetailVolume {
    /**
     * 
     * @type {string}
     * @memberof InstanceDetailVolume
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof InstanceDetailVolume
     */
    'path': string;
}
/**
 * 
 * @export
 * @interface InstanceEditor
 */
export interface InstanceEditor {
    /**
     * Descriptive name of the editor
     * @type {string}
     * @memberof InstanceEditor
     */
    'name': string;
    /**
     * Link to the editor of an instance
     * @type {string}
     * @memberof InstanceEditor
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface InstanceEnvironmentVariable
 */
export interface InstanceEnvironmentVariable {
    /**
     * 
     * @type {string}
     * @memberof InstanceEnvironmentVariable
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof InstanceEnvironmentVariable
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface InstanceLabel
 */
export interface InstanceLabel {
    /**
     * 
     * @type {string}
     * @memberof InstanceLabel
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof InstanceLabel
     */
    'value'?: string;
}
/**
 * @type InstancePortMapping
 * @export
 */
export type InstancePortMapping = InstancePortMappingRange | InstancePortMappingSingle;

/**
 * 
 * @export
 * @interface InstancePortMappingRange
 */
export interface InstancePortMappingRange {
    /**
     * 
     * @type {PortRange}
     * @memberof InstancePortMappingRange
     */
    'host_ports': PortRange;
    /**
     * 
     * @type {PortRange}
     * @memberof InstancePortMappingRange
     */
    'container_ports': PortRange;
}
/**
 * 
 * @export
 * @interface InstancePortMappingSingle
 */
export interface InstancePortMappingSingle {
    /**
     * 
     * @type {number}
     * @memberof InstancePortMappingSingle
     */
    'host_port': number;
    /**
     * 
     * @type {number}
     * @memberof InstancePortMappingSingle
     */
    'container_port': number;
}
/**
 * 
 * @export
 * @interface InstancePorts
 */
export interface InstancePorts {
    /**
     * 
     * @type {Array<InstancePortMapping>}
     * @memberof InstancePorts
     */
    'tcp': Array<InstancePortMapping>;
    /**
     * 
     * @type {Array<InstancePortMapping>}
     * @memberof InstancePorts
     */
    'udp': Array<InstancePortMapping>;
    /**
     * 
     * @type {Array<InstancePortMapping>}
     * @memberof InstancePorts
     */
    'sctp': Array<InstancePortMapping>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const InstanceStatus = {
    NotCreated: 'not created',
    Requested: 'requested',
    ResourcesReady: 'resources ready',
    Created: 'created',
    Stopped: 'stopped',
    Running: 'running',
    Orphaned: 'orphaned',
    Unknown: 'unknown'
} as const;

export type InstanceStatus = typeof InstanceStatus[keyof typeof InstanceStatus];


/**
 * 
 * @export
 * @interface InstancesCreatePostRequest
 */
export interface InstancesCreatePostRequest {
    /**
     * 
     * @type {AppKey}
     * @memberof InstancesCreatePostRequest
     */
    'appKey': AppKey;
    /**
     * Instance name
     * @type {string}
     * @memberof InstancesCreatePostRequest
     */
    'instanceName'?: string;
}
/**
 * 
 * @export
 * @interface InstancesInstanceIdConfigEnvironmentVariableNameGet200Response
 */
export interface InstancesInstanceIdConfigEnvironmentVariableNameGet200Response {
    /**
     * 
     * @type {string}
     * @memberof InstancesInstanceIdConfigEnvironmentVariableNameGet200Response
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface InstancesInstanceIdConfigLabelsLabelNameGet200Response
 */
export interface InstancesInstanceIdConfigLabelsLabelNameGet200Response {
    /**
     * 
     * @type {string}
     * @memberof InstancesInstanceIdConfigLabelsLabelNameGet200Response
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface InstancesInstanceIdConfigNetworksPostRequest
 */
export interface InstancesInstanceIdConfigNetworksPostRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesInstanceIdConfigNetworksPostRequest
     */
    'network_id': string;
    /**
     * 
     * @type {string}
     * @memberof InstancesInstanceIdConfigNetworksPostRequest
     */
    'ip_address_suggestion'?: string;
}
/**
 * @type InstancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest
 * @export
 */
export type InstancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest = PortRange | number;

/**
 * 
 * @export
 * @interface InstancesInstanceIdGet200Response
 */
export interface InstancesInstanceIdGet200Response {
    /**
     * 
     * @type {string}
     * @memberof InstancesInstanceIdGet200Response
     */
    'instanceId': string;
    /**
     * Instance name
     * @type {string}
     * @memberof InstancesInstanceIdGet200Response
     */
    'instanceName': string;
    /**
     * 
     * @type {AppKey}
     * @memberof InstancesInstanceIdGet200Response
     */
    'appKey': AppKey;
    /**
     * 
     * @type {InstanceStatus}
     * @memberof InstancesInstanceIdGet200Response
     */
    'status': InstanceStatus;
    /**
     * 
     * @type {InstanceStatus}
     * @memberof InstancesInstanceIdGet200Response
     */
    'desired': InstanceStatus;
    /**
     * 
     * @type {Array<InstanceDetailConfigFile>}
     * @memberof InstancesInstanceIdGet200Response
     */
    'configFiles': Array<InstanceDetailConfigFile>;
    /**
     * Hostname of an instance
     * @type {string}
     * @memberof InstancesInstanceIdGet200Response
     */
    'hostname': string;
    /**
     * IP address of an instance
     * @type {string}
     * @memberof InstancesInstanceIdGet200Response
     */
    'ipAddress': string;
    /**
     * Allocated network ports of an instance
     * @type {Array<InstanceDetailPort>}
     * @memberof InstancesInstanceIdGet200Response
     */
    'ports': Array<InstanceDetailPort>;
    /**
     * Automatic volumes of an instance
     * @type {Array<InstanceDetailVolume>}
     * @memberof InstancesInstanceIdGet200Response
     */
    'volumes': Array<InstanceDetailVolume>;
    /**
     * 
     * @type {Array<InstanceEditor>}
     * @memberof InstancesInstanceIdGet200Response
     */
    'editors'?: Array<InstanceEditor>;
}


/**
 * 
 * @export
 * @interface InstancesInstanceIdLogsGet200Response
 */
export interface InstancesInstanceIdLogsGet200Response {
    /**
     * 
     * @type {string}
     * @memberof InstancesInstanceIdLogsGet200Response
     */
    'stdout': string;
    /**
     * 
     * @type {string}
     * @memberof InstancesInstanceIdLogsGet200Response
     */
    'stderr': string;
}
/**
 * 
 * @export
 * @interface InstancesInstanceIdPatchRequest
 */
export interface InstancesInstanceIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesInstanceIdPatchRequest
     */
    'to': string;
}
/**
 * 
 * @export
 * @interface Ipam
 */
export interface Ipam {
    /**
     * 
     * @type {Ipv4Network}
     * @memberof Ipam
     */
    'ipv4_subnet'?: Ipv4Network;
    /**
     * 
     * @type {string}
     * @memberof Ipam
     */
    'ipv4_gateway'?: string;
}
/**
 * 
 * @export
 * @interface Ipv4Network
 */
export interface Ipv4Network {
    /**
     * 
     * @type {string}
     * @memberof Ipv4Network
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof Ipv4Network
     */
    'netmask': string;
}
/**
 * 
 * @export
 * @interface Ipv6Network
 */
export interface Ipv6Network {
    /**
     * 
     * @type {string}
     * @memberof Ipv6Network
     */
    'address': string;
    /**
     * 
     * @type {number}
     * @memberof Ipv6Network
     */
    'prefix_len': number;
}
/**
 * 
 * @export
 * @interface Job
 */
export interface Job {
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'id': number;
    /**
     * 
     * @type {JobStatus}
     * @memberof Job
     */
    'status': JobStatus;
    /**
     * 
     * @type {string}
     * @memberof Job
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof Job
     */
    'numSteps': number;
    /**
     * 
     * @type {JobStep}
     * @memberof Job
     */
    'currentStep': JobStep;
    /**
     * 
     * @type {JobResult}
     * @memberof Job
     */
    'result': JobResult;
}


/**
 * Job metadata for accepted requests
 * @export
 * @interface JobMeta
 */
export interface JobMeta {
    /**
     * 
     * @type {number}
     * @memberof JobMeta
     */
    'jobId': number;
}
/**
 * 
 * @export
 * @interface JobResult
 */
export interface JobResult {
    /**
     * 
     * @type {number}
     * @memberof JobResult
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof JobResult
     */
    'message': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const JobStatus = {
    Pending: 'pending',
    Queued: 'queued',
    Running: 'running',
    Cancelled: 'cancelled',
    Successful: 'successful',
    Failed: 'failed',
    Unknown: 'unknown'
} as const;

export type JobStatus = typeof JobStatus[keyof typeof JobStatus];


/**
 * 
 * @export
 * @interface JobStep
 */
export interface JobStep {
    /**
     * 
     * @type {string}
     * @memberof JobStep
     */
    'description': string;
    /**
     * 
     * @type {number}
     * @memberof JobStep
     */
    'num': number;
    /**
     * 
     * @type {number}
     * @memberof JobStep
     */
    'unit': number;
    /**
     * 
     * @type {number}
     * @memberof JobStep
     */
    'unitsTotal': number;
    /**
     * 
     * @type {number}
     * @memberof JobStep
     */
    'unitsDone': number;
    /**
     * 
     * @type {number}
     * @memberof JobStep
     */
    'rate': number;
}
/**
 * 
 * @export
 * @interface Jwt
 */
export interface Jwt {
    /**
     * 
     * @type {string}
     * @memberof Jwt
     */
    'token': string;
    /**
     * 
     * @type {number}
     * @memberof Jwt
     */
    'token_expires': number;
}
/**
 * 
 * @export
 * @interface Mounts
 */
export interface Mounts {
    /**
     * 
     * @type {Array<BindMount>}
     * @memberof Mounts
     */
    'bind_mounts'?: Array<BindMount>;
    /**
     * 
     * @type {Array<InstanceDetailVolume>}
     * @memberof Mounts
     */
    'volume_mounts'?: Array<InstanceDetailVolume>;
}
/**
 * @type Network
 * @export
 */
export type Network = Ipv4Network | Ipv6Network;

/**
 * 
 * @export
 * @interface NetworkAdapter
 */
export interface NetworkAdapter {
    /**
     * 
     * @type {string}
     * @memberof NetworkAdapter
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkAdapter
     */
    'ipv4_addresses'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkAdapter
     */
    'ipv6_addresses'?: Array<string>;
    /**
     * 
     * @type {Array<Network>}
     * @memberof NetworkAdapter
     */
    'networks'?: Array<Network>;
    /**
     * 
     * @type {string}
     * @memberof NetworkAdapter
     */
    'gateway'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkAdapter
     */
    'mac_address'?: string;
    /**
     * 
     * @type {NetworkType}
     * @memberof NetworkAdapter
     */
    'net_type': NetworkType;
    /**
     * 
     * @type {boolean}
     * @memberof NetworkAdapter
     */
    'is_connected': boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const NetworkKind = {
    Internal: 'Internal',
    Bridge: 'Bridge',
    Macvlan: 'MACVLAN',
    IpvlanL2: 'IpvlanL2',
    IpvlanL3: 'IpvlanL3'
} as const;

export type NetworkKind = typeof NetworkKind[keyof typeof NetworkKind];


/**
 * 
 * @export
 * @enum {string}
 */

export const NetworkType = {
    Unknown: 'Unknown',
    Wired: 'Wired',
    Wireless: 'Wireless',
    Local: 'Local',
    Bridge: 'Bridge',
    Virtual: 'Virtual'
} as const;

export type NetworkType = typeof NetworkType[keyof typeof NetworkType];


/**
 * Additional info
 * @export
 * @interface OptionalAdditionalInfo
 */
export interface OptionalAdditionalInfo {
    /**
     * 
     * @type {string}
     * @memberof OptionalAdditionalInfo
     */
    'additionalInfo'?: string;
}
/**
 * 
 * @export
 * @interface PortRange
 */
export interface PortRange {
    /**
     * 
     * @type {number}
     * @memberof PortRange
     */
    'start': number;
    /**
     * 
     * @type {number}
     * @memberof PortRange
     */
    'end': number;
}
/**
 * 
 * @export
 * @interface PutDeploymentNetwork
 */
export interface PutDeploymentNetwork {
    /**
     * 
     * @type {NetworkKind}
     * @memberof PutDeploymentNetwork
     */
    'network_kind': NetworkKind;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PutDeploymentNetwork
     */
    'options'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PutDeploymentNetwork
     */
    'parent_adapter'?: string;
    /**
     * 
     * @type {Ipam}
     * @memberof PutDeploymentNetwork
     */
    'ipam'?: Ipam;
}


/**
 * 
 * @export
 * @interface SessionId
 */
export interface SessionId {
    /**
     * 
     * @type {string}
     * @memberof SessionId
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof SessionId
     */
    'timestamp'?: number;
}
/**
 * 
 * @export
 * @interface SystemDistro
 */
export interface SystemDistro {
    /**
     * 
     * @type {string}
     * @memberof SystemDistro
     */
    'codename': string;
    /**
     * 
     * @type {string}
     * @memberof SystemDistro
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SystemDistro
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SystemDistro
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface SystemInfo
 */
export interface SystemInfo {
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'arch': string;
    /**
     * 
     * @type {SystemDistro}
     * @memberof SystemInfo
     */
    'distro': SystemDistro;
    /**
     * 
     * @type {SystemKernel}
     * @memberof SystemInfo
     */
    'kernel': SystemKernel;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'platform': string;
}
/**
 * 
 * @export
 * @interface SystemKernel
 */
export interface SystemKernel {
    /**
     * 
     * @type {string}
     * @memberof SystemKernel
     */
    'build': string;
    /**
     * 
     * @type {string}
     * @memberof SystemKernel
     */
    'machine': string;
    /**
     * 
     * @type {string}
     * @memberof SystemKernel
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface SystemVersionGet200Response
 */
export interface SystemVersionGet200Response {
    /**
     * 
     * @type {string}
     * @memberof SystemVersionGet200Response
     */
    'api': string;
    /**
     * 
     * @type {string}
     * @memberof SystemVersionGet200Response
     */
    'core': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TransportProtocol = {
    Tcp: 'tcp',
    Udp: 'udp',
    Sctp: 'sctp'
} as const;

export type TransportProtocol = typeof TransportProtocol[keyof typeof TransportProtocol];


/**
 * 
 * @export
 * @interface UsbDevice
 */
export interface UsbDevice {
    /**
     * 
     * @type {string}
     * @memberof UsbDevice
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof UsbDevice
     */
    'pid': number;
    /**
     * 
     * @type {string}
     * @memberof UsbDevice
     */
    'port': string;
    /**
     * 
     * @type {string}
     * @memberof UsbDevice
     */
    'vendor': string;
    /**
     * 
     * @type {number}
     * @memberof UsbDevice
     */
    'vid': number;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'ID': number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'user_email': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'user_login': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'display_name': string;
}

/**
 * AppsApi - axios parameter creator
 * @export
 */
export const AppsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Uninstall one or all versions an App
         * @param {string} app 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppDelete: async (app: string, version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'app' is not null or undefined
            assertParamExists('appsAppDelete', 'app', app)
            const localVarPath = `/apps/{app}`
                .replace(`{${"app"}}`, encodeURIComponent(String(app)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query all versions or specific versions of an App
         * @param {string} app 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppGet: async (app: string, version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'app' is not null or undefined
            assertParamExists('appsAppGet', 'app', app)
            const localVarPath = `/apps/{app}`
                .replace(`{${"app"}}`, encodeURIComponent(String(app)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query installed Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/apps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Install an App from the FLECS marketplace
         * @param {AppsInstallPostRequest} appsInstallPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsInstallPost: async (appsInstallPostRequest: AppsInstallPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appsInstallPostRequest' is not null or undefined
            assertParamExists('appsInstallPost', 'appsInstallPostRequest', appsInstallPostRequest)
            const localVarPath = `/apps/install`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appsInstallPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sideload an App from its manifest
         * @param {AppsSideloadPostRequest} appsSideloadPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsSideloadPost: async (appsSideloadPostRequest: AppsSideloadPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'appsSideloadPostRequest' is not null or undefined
            assertParamExists('appsSideloadPost', 'appsSideloadPostRequest', appsSideloadPostRequest)
            const localVarPath = `/apps/sideload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(appsSideloadPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppsApi - functional programming interface
 * @export
 */
export const AppsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AppsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Uninstall one or all versions an App
         * @param {string} app 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsAppDelete(app: string, version?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsAppDelete(app, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.appsAppDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Query all versions or specific versions of an App
         * @param {string} app 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsAppGet(app: string, version?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InstalledApp>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsAppGet(app, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.appsAppGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Query installed Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InstalledApp>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.appsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Install an App from the FLECS marketplace
         * @param {AppsInstallPostRequest} appsInstallPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsInstallPost(appsInstallPostRequest: AppsInstallPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsInstallPost(appsInstallPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.appsInstallPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Sideload an App from its manifest
         * @param {AppsSideloadPostRequest} appsSideloadPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async appsSideloadPost(appsSideloadPostRequest: AppsSideloadPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.appsSideloadPost(appsSideloadPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AppsApi.appsSideloadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AppsApi - factory interface
 * @export
 */
export const AppsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AppsApiFp(configuration)
    return {
        /**
         * 
         * @summary Uninstall one or all versions an App
         * @param {AppsApiAppsAppDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppDelete(requestParameters: AppsApiAppsAppDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobMeta> {
            return localVarFp.appsAppDelete(requestParameters.app, requestParameters.version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query all versions or specific versions of an App
         * @param {AppsApiAppsAppGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsAppGet(requestParameters: AppsApiAppsAppGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<InstalledApp>> {
            return localVarFp.appsAppGet(requestParameters.app, requestParameters.version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query installed Apps
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<InstalledApp>> {
            return localVarFp.appsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Install an App from the FLECS marketplace
         * @param {AppsApiAppsInstallPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsInstallPost(requestParameters: AppsApiAppsInstallPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobMeta> {
            return localVarFp.appsInstallPost(requestParameters.appsInstallPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sideload an App from its manifest
         * @param {AppsApiAppsSideloadPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        appsSideloadPost(requestParameters: AppsApiAppsSideloadPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobMeta> {
            return localVarFp.appsSideloadPost(requestParameters.appsSideloadPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for appsAppDelete operation in AppsApi.
 * @export
 * @interface AppsApiAppsAppDeleteRequest
 */
export interface AppsApiAppsAppDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof AppsApiAppsAppDelete
     */
    readonly app: string

    /**
     * 
     * @type {string}
     * @memberof AppsApiAppsAppDelete
     */
    readonly version?: string
}

/**
 * Request parameters for appsAppGet operation in AppsApi.
 * @export
 * @interface AppsApiAppsAppGetRequest
 */
export interface AppsApiAppsAppGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AppsApiAppsAppGet
     */
    readonly app: string

    /**
     * 
     * @type {string}
     * @memberof AppsApiAppsAppGet
     */
    readonly version?: string
}

/**
 * Request parameters for appsInstallPost operation in AppsApi.
 * @export
 * @interface AppsApiAppsInstallPostRequest
 */
export interface AppsApiAppsInstallPostRequest {
    /**
     * 
     * @type {AppsInstallPostRequest}
     * @memberof AppsApiAppsInstallPost
     */
    readonly appsInstallPostRequest: AppsInstallPostRequest
}

/**
 * Request parameters for appsSideloadPost operation in AppsApi.
 * @export
 * @interface AppsApiAppsSideloadPostRequest
 */
export interface AppsApiAppsSideloadPostRequest {
    /**
     * 
     * @type {AppsSideloadPostRequest}
     * @memberof AppsApiAppsSideloadPost
     */
    readonly appsSideloadPostRequest: AppsSideloadPostRequest
}

/**
 * AppsApi - object-oriented interface
 * @export
 * @class AppsApi
 * @extends {BaseAPI}
 */
export class AppsApi extends BaseAPI {
    /**
     * 
     * @summary Uninstall one or all versions an App
     * @param {AppsApiAppsAppDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsAppDelete(requestParameters: AppsApiAppsAppDeleteRequest, options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).appsAppDelete(requestParameters.app, requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query all versions or specific versions of an App
     * @param {AppsApiAppsAppGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsAppGet(requestParameters: AppsApiAppsAppGetRequest, options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).appsAppGet(requestParameters.app, requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query installed Apps
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsGet(options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).appsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Install an App from the FLECS marketplace
     * @param {AppsApiAppsInstallPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsInstallPost(requestParameters: AppsApiAppsInstallPostRequest, options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).appsInstallPost(requestParameters.appsInstallPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sideload an App from its manifest
     * @param {AppsApiAppsSideloadPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public appsSideloadPost(requestParameters: AppsApiAppsSideloadPostRequest, options?: RawAxiosRequestConfig) {
        return AppsApiFp(this.configuration).appsSideloadPost(requestParameters.appsSideloadPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConsoleApi - axios parameter creator
 * @export
 */
export const ConsoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Remove the authentication information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consoleAuthenticationDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/console/authentication`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the authentication information
         * @param {AuthResponseData} authResponseData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consoleAuthenticationPut: async (authResponseData: AuthResponseData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authResponseData' is not null or undefined
            assertParamExists('consoleAuthenticationPut', 'authResponseData', authResponseData)
            const localVarPath = `/console/authentication`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authResponseData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConsoleApi - functional programming interface
 * @export
 */
export const ConsoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConsoleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Remove the authentication information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consoleAuthenticationDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consoleAuthenticationDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConsoleApi.consoleAuthenticationDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the authentication information
         * @param {AuthResponseData} authResponseData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async consoleAuthenticationPut(authResponseData: AuthResponseData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.consoleAuthenticationPut(authResponseData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConsoleApi.consoleAuthenticationPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConsoleApi - factory interface
 * @export
 */
export const ConsoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConsoleApiFp(configuration)
    return {
        /**
         * 
         * @summary Remove the authentication information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consoleAuthenticationDelete(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.consoleAuthenticationDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the authentication information
         * @param {ConsoleApiConsoleAuthenticationPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        consoleAuthenticationPut(requestParameters: ConsoleApiConsoleAuthenticationPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.consoleAuthenticationPut(requestParameters.authResponseData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for consoleAuthenticationPut operation in ConsoleApi.
 * @export
 * @interface ConsoleApiConsoleAuthenticationPutRequest
 */
export interface ConsoleApiConsoleAuthenticationPutRequest {
    /**
     * 
     * @type {AuthResponseData}
     * @memberof ConsoleApiConsoleAuthenticationPut
     */
    readonly authResponseData: AuthResponseData
}

/**
 * ConsoleApi - object-oriented interface
 * @export
 * @class ConsoleApi
 * @extends {BaseAPI}
 */
export class ConsoleApi extends BaseAPI {
    /**
     * 
     * @summary Remove the authentication information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsoleApi
     */
    public consoleAuthenticationDelete(options?: RawAxiosRequestConfig) {
        return ConsoleApiFp(this.configuration).consoleAuthenticationDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the authentication information
     * @param {ConsoleApiConsoleAuthenticationPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConsoleApi
     */
    public consoleAuthenticationPut(requestParameters: ConsoleApiConsoleAuthenticationPutRequest, options?: RawAxiosRequestConfig) {
        return ConsoleApiFp(this.configuration).consoleAuthenticationPut(requestParameters.authResponseData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeploymentsApi - axios parameter creator
 * @export
 */
export const DeploymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} deploymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDeploymentIdNetworksGet: async (deploymentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentId' is not null or undefined
            assertParamExists('deploymentsDeploymentIdNetworksGet', 'deploymentId', deploymentId)
            const localVarPath = `/deployments/{deployment_id}/networks`
                .replace(`{${"deployment_id"}}`, encodeURIComponent(String(deploymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} deploymentId 
         * @param {string} networkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDeploymentIdNetworksNetworkIdDhcpIpv4Post: async (deploymentId: string, networkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentId' is not null or undefined
            assertParamExists('deploymentsDeploymentIdNetworksNetworkIdDhcpIpv4Post', 'deploymentId', deploymentId)
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('deploymentsDeploymentIdNetworksNetworkIdDhcpIpv4Post', 'networkId', networkId)
            const localVarPath = `/deployments/{deployment_id}/networks/{network_id}/dhcp/ipv4`
                .replace(`{${"deployment_id"}}`, encodeURIComponent(String(deploymentId)))
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} deploymentId 
         * @param {string} networkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDeploymentIdNetworksNetworkIdGet: async (deploymentId: string, networkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentId' is not null or undefined
            assertParamExists('deploymentsDeploymentIdNetworksNetworkIdGet', 'deploymentId', deploymentId)
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('deploymentsDeploymentIdNetworksNetworkIdGet', 'networkId', networkId)
            const localVarPath = `/deployments/{deployment_id}/networks/{network_id}`
                .replace(`{${"deployment_id"}}`, encodeURIComponent(String(deploymentId)))
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} deploymentId 
         * @param {string} networkId 
         * @param {PutDeploymentNetwork} putDeploymentNetwork 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDeploymentIdNetworksNetworkIdPut: async (deploymentId: string, networkId: string, putDeploymentNetwork: PutDeploymentNetwork, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deploymentId' is not null or undefined
            assertParamExists('deploymentsDeploymentIdNetworksNetworkIdPut', 'deploymentId', deploymentId)
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('deploymentsDeploymentIdNetworksNetworkIdPut', 'networkId', networkId)
            // verify required parameter 'putDeploymentNetwork' is not null or undefined
            assertParamExists('deploymentsDeploymentIdNetworksNetworkIdPut', 'putDeploymentNetwork', putDeploymentNetwork)
            const localVarPath = `/deployments/{deployment_id}/networks/{network_id}`
                .replace(`{${"deployment_id"}}`, encodeURIComponent(String(deploymentId)))
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(putDeploymentNetwork, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentsApi - functional programming interface
 * @export
 */
export const DeploymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeploymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} deploymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsDeploymentIdNetworksGet(deploymentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DeploymentNetwork>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsDeploymentIdNetworksGet(deploymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsDeploymentIdNetworksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} deploymentId 
         * @param {string} networkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsDeploymentIdNetworksNetworkIdDhcpIpv4Post(deploymentId: string, networkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentsDeploymentIdNetworksNetworkIdDhcpIpv4Post200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsDeploymentIdNetworksNetworkIdDhcpIpv4Post(deploymentId, networkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsDeploymentIdNetworksNetworkIdDhcpIpv4Post']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} deploymentId 
         * @param {string} networkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsDeploymentIdNetworksNetworkIdGet(deploymentId: string, networkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeploymentNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsDeploymentIdNetworksNetworkIdGet(deploymentId, networkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsDeploymentIdNetworksNetworkIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} deploymentId 
         * @param {string} networkId 
         * @param {PutDeploymentNetwork} putDeploymentNetwork 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deploymentsDeploymentIdNetworksNetworkIdPut(deploymentId: string, networkId: string, putDeploymentNetwork: PutDeploymentNetwork, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deploymentsDeploymentIdNetworksNetworkIdPut(deploymentId, networkId, putDeploymentNetwork, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeploymentsApi.deploymentsDeploymentIdNetworksNetworkIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeploymentsApi - factory interface
 * @export
 */
export const DeploymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeploymentsApiFp(configuration)
    return {
        /**
         * 
         * @param {DeploymentsApiDeploymentsDeploymentIdNetworksGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDeploymentIdNetworksGet(requestParameters: DeploymentsApiDeploymentsDeploymentIdNetworksGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<DeploymentNetwork>> {
            return localVarFp.deploymentsDeploymentIdNetworksGet(requestParameters.deploymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdDhcpIpv4PostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDeploymentIdNetworksNetworkIdDhcpIpv4Post(requestParameters: DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdDhcpIpv4PostRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentsDeploymentIdNetworksNetworkIdDhcpIpv4Post200Response> {
            return localVarFp.deploymentsDeploymentIdNetworksNetworkIdDhcpIpv4Post(requestParameters.deploymentId, requestParameters.networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDeploymentIdNetworksNetworkIdGet(requestParameters: DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeploymentNetwork> {
            return localVarFp.deploymentsDeploymentIdNetworksNetworkIdGet(requestParameters.deploymentId, requestParameters.networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deploymentsDeploymentIdNetworksNetworkIdPut(requestParameters: DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deploymentsDeploymentIdNetworksNetworkIdPut(requestParameters.deploymentId, requestParameters.networkId, requestParameters.putDeploymentNetwork, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deploymentsDeploymentIdNetworksGet operation in DeploymentsApi.
 * @export
 * @interface DeploymentsApiDeploymentsDeploymentIdNetworksGetRequest
 */
export interface DeploymentsApiDeploymentsDeploymentIdNetworksGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentsApiDeploymentsDeploymentIdNetworksGet
     */
    readonly deploymentId: string
}

/**
 * Request parameters for deploymentsDeploymentIdNetworksNetworkIdDhcpIpv4Post operation in DeploymentsApi.
 * @export
 * @interface DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdDhcpIpv4PostRequest
 */
export interface DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdDhcpIpv4PostRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdDhcpIpv4Post
     */
    readonly deploymentId: string

    /**
     * 
     * @type {string}
     * @memberof DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdDhcpIpv4Post
     */
    readonly networkId: string
}

/**
 * Request parameters for deploymentsDeploymentIdNetworksNetworkIdGet operation in DeploymentsApi.
 * @export
 * @interface DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdGetRequest
 */
export interface DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdGet
     */
    readonly deploymentId: string

    /**
     * 
     * @type {string}
     * @memberof DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdGet
     */
    readonly networkId: string
}

/**
 * Request parameters for deploymentsDeploymentIdNetworksNetworkIdPut operation in DeploymentsApi.
 * @export
 * @interface DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdPutRequest
 */
export interface DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdPut
     */
    readonly deploymentId: string

    /**
     * 
     * @type {string}
     * @memberof DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdPut
     */
    readonly networkId: string

    /**
     * 
     * @type {PutDeploymentNetwork}
     * @memberof DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdPut
     */
    readonly putDeploymentNetwork: PutDeploymentNetwork
}

/**
 * DeploymentsApi - object-oriented interface
 * @export
 * @class DeploymentsApi
 * @extends {BaseAPI}
 */
export class DeploymentsApi extends BaseAPI {
    /**
     * 
     * @param {DeploymentsApiDeploymentsDeploymentIdNetworksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsDeploymentIdNetworksGet(requestParameters: DeploymentsApiDeploymentsDeploymentIdNetworksGetRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsDeploymentIdNetworksGet(requestParameters.deploymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdDhcpIpv4PostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsDeploymentIdNetworksNetworkIdDhcpIpv4Post(requestParameters: DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdDhcpIpv4PostRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsDeploymentIdNetworksNetworkIdDhcpIpv4Post(requestParameters.deploymentId, requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsDeploymentIdNetworksNetworkIdGet(requestParameters: DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdGetRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsDeploymentIdNetworksNetworkIdGet(requestParameters.deploymentId, requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentsApi
     */
    public deploymentsDeploymentIdNetworksNetworkIdPut(requestParameters: DeploymentsApiDeploymentsDeploymentIdNetworksNetworkIdPutRequest, options?: RawAxiosRequestConfig) {
        return DeploymentsApiFp(this.configuration).deploymentsDeploymentIdNetworksNetworkIdPut(requestParameters.deploymentId, requestParameters.networkId, requestParameters.putDeploymentNetwork, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DeviceApi - axios parameter creator
 * @export
 */
export const DeviceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Execute device activation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceLicenseActivationPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/device/license/activation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if device is activated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceLicenseActivationStatusGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/device/license/activation/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceLicenseInfoGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/device/license/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Dosschema} dosschema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceOnboardingPost: async (dosschema: Dosschema, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dosschema' is not null or undefined
            assertParamExists('deviceOnboardingPost', 'dosschema', dosschema)
            const localVarPath = `/device/onboarding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dosschema, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceApi - functional programming interface
 * @export
 */
export const DeviceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeviceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Execute device activation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deviceLicenseActivationPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdditionalInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deviceLicenseActivationPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceApi.deviceLicenseActivationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check if device is activated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deviceLicenseActivationStatusGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceLicenseActivationStatusGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deviceLicenseActivationStatusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceApi.deviceLicenseActivationStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get information about license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deviceLicenseInfoGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceLicenseInfoGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deviceLicenseInfoGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceApi.deviceLicenseInfoGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Dosschema} dosschema 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deviceOnboardingPost(dosschema: Dosschema, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deviceOnboardingPost(dosschema, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DeviceApi.deviceOnboardingPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DeviceApi - factory interface
 * @export
 */
export const DeviceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeviceApiFp(configuration)
    return {
        /**
         * 
         * @summary Execute device activation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceLicenseActivationPost(options?: RawAxiosRequestConfig): AxiosPromise<AdditionalInfo> {
            return localVarFp.deviceLicenseActivationPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if device is activated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceLicenseActivationStatusGet(options?: RawAxiosRequestConfig): AxiosPromise<DeviceLicenseActivationStatusGet200Response> {
            return localVarFp.deviceLicenseActivationStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about license
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceLicenseInfoGet(options?: RawAxiosRequestConfig): AxiosPromise<DeviceLicenseInfoGet200Response> {
            return localVarFp.deviceLicenseInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeviceApiDeviceOnboardingPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deviceOnboardingPost(requestParameters: DeviceApiDeviceOnboardingPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobMeta> {
            return localVarFp.deviceOnboardingPost(requestParameters.dosschema, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deviceOnboardingPost operation in DeviceApi.
 * @export
 * @interface DeviceApiDeviceOnboardingPostRequest
 */
export interface DeviceApiDeviceOnboardingPostRequest {
    /**
     * 
     * @type {Dosschema}
     * @memberof DeviceApiDeviceOnboardingPost
     */
    readonly dosschema: Dosschema
}

/**
 * DeviceApi - object-oriented interface
 * @export
 * @class DeviceApi
 * @extends {BaseAPI}
 */
export class DeviceApi extends BaseAPI {
    /**
     * 
     * @summary Execute device activation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public deviceLicenseActivationPost(options?: RawAxiosRequestConfig) {
        return DeviceApiFp(this.configuration).deviceLicenseActivationPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if device is activated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public deviceLicenseActivationStatusGet(options?: RawAxiosRequestConfig) {
        return DeviceApiFp(this.configuration).deviceLicenseActivationStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about license
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public deviceLicenseInfoGet(options?: RawAxiosRequestConfig) {
        return DeviceApiFp(this.configuration).deviceLicenseInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DeviceApiDeviceOnboardingPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceApi
     */
    public deviceOnboardingPost(requestParameters: DeviceApiDeviceOnboardingPostRequest, options?: RawAxiosRequestConfig) {
        return DeviceApiFp(this.configuration).deviceOnboardingPost(requestParameters.dosschema, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FlecsportApi - axios parameter creator
 * @export
 */
export const FlecsportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete specified export
         * @param {string} exportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportsExportIdDelete: async (exportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists('exportsExportIdDelete', 'exportId', exportId)
            const localVarPath = `/exports/{export_id}`
                .replace(`{${"export_id"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download specified export
         * @param {string} exportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportsExportIdGet: async (exportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportId' is not null or undefined
            assertParamExists('exportsExportIdGet', 'exportId', exportId)
            const localVarPath = `/exports/{export_id}`
                .replace(`{${"export_id"}}`, encodeURIComponent(String(exportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query all existing exports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an export
         * @param {ExportRequest} exportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportsPost: async (exportRequest: ExportRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportRequest' is not null or undefined
            assertParamExists('exportsPost', 'exportRequest', exportRequest)
            const localVarPath = `/exports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload and import an export file
         * @param {string} contentDisposition File name of the export, e.g. my-export.tar
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importsPost: async (contentDisposition: string, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentDisposition' is not null or undefined
            assertParamExists('importsPost', 'contentDisposition', contentDisposition)
            const localVarPath = `/imports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            if (contentDisposition != null) {
                localVarHeaderParameter['Content-Disposition'] = String(contentDisposition);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlecsportApi - functional programming interface
 * @export
 */
export const FlecsportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlecsportApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete specified export
         * @param {string} exportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportsExportIdDelete(exportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportsExportIdDelete(exportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlecsportApi.exportsExportIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download specified export
         * @param {string} exportId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportsExportIdGet(exportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportsExportIdGet(exportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlecsportApi.exportsExportIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Query all existing exports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlecsportApi.exportsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create an export
         * @param {ExportRequest} exportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportsPost(exportRequest: ExportRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportsPost(exportRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlecsportApi.exportsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload and import an export file
         * @param {string} contentDisposition File name of the export, e.g. my-export.tar
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importsPost(contentDisposition: string, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importsPost(contentDisposition, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlecsportApi.importsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FlecsportApi - factory interface
 * @export
 */
export const FlecsportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlecsportApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete specified export
         * @param {FlecsportApiExportsExportIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportsExportIdDelete(requestParameters: FlecsportApiExportsExportIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.exportsExportIdDelete(requestParameters.exportId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download specified export
         * @param {FlecsportApiExportsExportIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportsExportIdGet(requestParameters: FlecsportApiExportsExportIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.exportsExportIdGet(requestParameters.exportId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query all existing exports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.exportsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an export
         * @param {FlecsportApiExportsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportsPost(requestParameters: FlecsportApiExportsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobMeta> {
            return localVarFp.exportsPost(requestParameters.exportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload and import an export file
         * @param {FlecsportApiImportsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importsPost(requestParameters: FlecsportApiImportsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobMeta> {
            return localVarFp.importsPost(requestParameters.contentDisposition, requestParameters.file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for exportsExportIdDelete operation in FlecsportApi.
 * @export
 * @interface FlecsportApiExportsExportIdDeleteRequest
 */
export interface FlecsportApiExportsExportIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof FlecsportApiExportsExportIdDelete
     */
    readonly exportId: string
}

/**
 * Request parameters for exportsExportIdGet operation in FlecsportApi.
 * @export
 * @interface FlecsportApiExportsExportIdGetRequest
 */
export interface FlecsportApiExportsExportIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof FlecsportApiExportsExportIdGet
     */
    readonly exportId: string
}

/**
 * Request parameters for exportsPost operation in FlecsportApi.
 * @export
 * @interface FlecsportApiExportsPostRequest
 */
export interface FlecsportApiExportsPostRequest {
    /**
     * 
     * @type {ExportRequest}
     * @memberof FlecsportApiExportsPost
     */
    readonly exportRequest: ExportRequest
}

/**
 * Request parameters for importsPost operation in FlecsportApi.
 * @export
 * @interface FlecsportApiImportsPostRequest
 */
export interface FlecsportApiImportsPostRequest {
    /**
     * File name of the export, e.g. my-export.tar
     * @type {string}
     * @memberof FlecsportApiImportsPost
     */
    readonly contentDisposition: string

    /**
     * 
     * @type {File}
     * @memberof FlecsportApiImportsPost
     */
    readonly file?: File
}

/**
 * FlecsportApi - object-oriented interface
 * @export
 * @class FlecsportApi
 * @extends {BaseAPI}
 */
export class FlecsportApi extends BaseAPI {
    /**
     * 
     * @summary Delete specified export
     * @param {FlecsportApiExportsExportIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlecsportApi
     */
    public exportsExportIdDelete(requestParameters: FlecsportApiExportsExportIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return FlecsportApiFp(this.configuration).exportsExportIdDelete(requestParameters.exportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download specified export
     * @param {FlecsportApiExportsExportIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlecsportApi
     */
    public exportsExportIdGet(requestParameters: FlecsportApiExportsExportIdGetRequest, options?: RawAxiosRequestConfig) {
        return FlecsportApiFp(this.configuration).exportsExportIdGet(requestParameters.exportId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query all existing exports
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlecsportApi
     */
    public exportsGet(options?: RawAxiosRequestConfig) {
        return FlecsportApiFp(this.configuration).exportsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an export
     * @param {FlecsportApiExportsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlecsportApi
     */
    public exportsPost(requestParameters: FlecsportApiExportsPostRequest, options?: RawAxiosRequestConfig) {
        return FlecsportApiFp(this.configuration).exportsPost(requestParameters.exportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload and import an export file
     * @param {FlecsportApiImportsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlecsportApi
     */
    public importsPost(requestParameters: FlecsportApiImportsPostRequest, options?: RawAxiosRequestConfig) {
        return FlecsportApiFp(this.configuration).importsPost(requestParameters.contentDisposition, requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InstancesApi - axios parameter creator
 * @export
 */
export const InstancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create new instance of an installed App
         * @param {InstancesCreatePostRequest} instancesCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesCreatePost: async (instancesCreatePostRequest: InstancesCreatePostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instancesCreatePostRequest' is not null or undefined
            assertParamExists('instancesCreatePost', 'instancesCreatePostRequest', instancesCreatePostRequest)
            const localVarPath = `/instances/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(instancesCreatePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Query all instances of one or all Apps
         * @param {string} [app] 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesGet: async (app?: string, version?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/instances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (app !== undefined) {
                localVarQueryParameter['app'] = app;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all passed through usb devices of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigDevicesUsbDelete: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigDevicesUsbDelete', 'instanceId', instanceId)
            const localVarPath = `/instances/{instance_id}/config/devices/usb`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve passed through usb devices of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigDevicesUsbGet: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigDevicesUsbGet', 'instanceId', instanceId)
            const localVarPath = `/instances/{instance_id}/config/devices/usb`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete passed through usb device of the instance with the given port
         * @param {string} instanceId 
         * @param {string} port 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigDevicesUsbPortDelete: async (instanceId: string, port: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigDevicesUsbPortDelete', 'instanceId', instanceId)
            // verify required parameter 'port' is not null or undefined
            assertParamExists('instancesInstanceIdConfigDevicesUsbPortDelete', 'port', port)
            const localVarPath = `/instances/{instance_id}/config/devices/usb/{port}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"port"}}`, encodeURIComponent(String(port)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve passed through usb device of the instance with the given port
         * @param {string} instanceId 
         * @param {string} port 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigDevicesUsbPortGet: async (instanceId: string, port: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigDevicesUsbPortGet', 'instanceId', instanceId)
            // verify required parameter 'port' is not null or undefined
            assertParamExists('instancesInstanceIdConfigDevicesUsbPortGet', 'port', port)
            const localVarPath = `/instances/{instance_id}/config/devices/usb/{port}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"port"}}`, encodeURIComponent(String(port)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pass through usb device with the given port to the instance
         * @param {string} instanceId 
         * @param {string} port 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigDevicesUsbPortPut: async (instanceId: string, port: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigDevicesUsbPortPut', 'instanceId', instanceId)
            // verify required parameter 'port' is not null or undefined
            assertParamExists('instancesInstanceIdConfigDevicesUsbPortPut', 'port', port)
            const localVarPath = `/instances/{instance_id}/config/devices/usb/{port}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"port"}}`, encodeURIComponent(String(port)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete environment of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigEnvironmentDelete: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigEnvironmentDelete', 'instanceId', instanceId)
            const localVarPath = `/instances/{instance_id}/config/environment`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve environment of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigEnvironmentGet: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigEnvironmentGet', 'instanceId', instanceId)
            const localVarPath = `/instances/{instance_id}/config/environment`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Modify or create environment of an instance
         * @param {string} instanceId 
         * @param {Array<InstanceEnvironmentVariable>} instanceEnvironmentVariable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigEnvironmentPut: async (instanceId: string, instanceEnvironmentVariable: Array<InstanceEnvironmentVariable>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigEnvironmentPut', 'instanceId', instanceId)
            // verify required parameter 'instanceEnvironmentVariable' is not null or undefined
            assertParamExists('instancesInstanceIdConfigEnvironmentPut', 'instanceEnvironmentVariable', instanceEnvironmentVariable)
            const localVarPath = `/instances/{instance_id}/config/environment`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(instanceEnvironmentVariable, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an environment variable of an instance
         * @param {string} instanceId 
         * @param {string} variableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigEnvironmentVariableNameDelete: async (instanceId: string, variableName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigEnvironmentVariableNameDelete', 'instanceId', instanceId)
            // verify required parameter 'variableName' is not null or undefined
            assertParamExists('instancesInstanceIdConfigEnvironmentVariableNameDelete', 'variableName', variableName)
            const localVarPath = `/instances/{instance_id}/config/environment/{variable_name}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"variable_name"}}`, encodeURIComponent(String(variableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve the value of an environment variable
         * @param {string} instanceId 
         * @param {string} variableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigEnvironmentVariableNameGet: async (instanceId: string, variableName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigEnvironmentVariableNameGet', 'instanceId', instanceId)
            // verify required parameter 'variableName' is not null or undefined
            assertParamExists('instancesInstanceIdConfigEnvironmentVariableNameGet', 'variableName', variableName)
            const localVarPath = `/instances/{instance_id}/config/environment/{variable_name}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"variable_name"}}`, encodeURIComponent(String(variableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set the value of an environment variable of an instance
         * @param {string} instanceId 
         * @param {string} variableName 
         * @param {InstancesInstanceIdConfigEnvironmentVariableNameGet200Response} instancesInstanceIdConfigEnvironmentVariableNameGet200Response 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigEnvironmentVariableNamePut: async (instanceId: string, variableName: string, instancesInstanceIdConfigEnvironmentVariableNameGet200Response: InstancesInstanceIdConfigEnvironmentVariableNameGet200Response, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigEnvironmentVariableNamePut', 'instanceId', instanceId)
            // verify required parameter 'variableName' is not null or undefined
            assertParamExists('instancesInstanceIdConfigEnvironmentVariableNamePut', 'variableName', variableName)
            // verify required parameter 'instancesInstanceIdConfigEnvironmentVariableNameGet200Response' is not null or undefined
            assertParamExists('instancesInstanceIdConfigEnvironmentVariableNamePut', 'instancesInstanceIdConfigEnvironmentVariableNameGet200Response', instancesInstanceIdConfigEnvironmentVariableNameGet200Response)
            const localVarPath = `/instances/{instance_id}/config/environment/{variable_name}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"variable_name"}}`, encodeURIComponent(String(variableName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(instancesInstanceIdConfigEnvironmentVariableNameGet200Response, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get configuration of an Instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigGet: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigGet', 'instanceId', instanceId)
            const localVarPath = `/instances/{instance_id}/config`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve labels of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigLabelsGet: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigLabelsGet', 'instanceId', instanceId)
            const localVarPath = `/instances/{instance_id}/config/labels`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve value of a specific label of an instance
         * @param {string} instanceId 
         * @param {string} labelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigLabelsLabelNameGet: async (instanceId: string, labelName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigLabelsLabelNameGet', 'instanceId', instanceId)
            // verify required parameter 'labelName' is not null or undefined
            assertParamExists('instancesInstanceIdConfigLabelsLabelNameGet', 'labelName', labelName)
            const localVarPath = `/instances/{instance_id}/config/labels/{label_name}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"label_name"}}`, encodeURIComponent(String(labelName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve bind mount of an instance
         * @param {string} instanceId 
         * @param {string} containerPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigMountsBindContainerPathGet: async (instanceId: string, containerPath: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigMountsBindContainerPathGet', 'instanceId', instanceId)
            // verify required parameter 'containerPath' is not null or undefined
            assertParamExists('instancesInstanceIdConfigMountsBindContainerPathGet', 'containerPath', containerPath)
            const localVarPath = `/instances/{instance_id}/config/mounts/bind/{container_path}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"container_path"}}`, encodeURIComponent(String(containerPath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve bind mounts of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigMountsBindGet: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigMountsBindGet', 'instanceId', instanceId)
            const localVarPath = `/instances/{instance_id}/config/mounts/bind`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve volumes of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigMountsGet: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigMountsGet', 'instanceId', instanceId)
            const localVarPath = `/instances/{instance_id}/config/mounts`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve volumes mounts of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigMountsVolumesGet: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigMountsVolumesGet', 'instanceId', instanceId)
            const localVarPath = `/instances/{instance_id}/config/mounts/volumes`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve volume mount of an instance
         * @param {string} instanceId 
         * @param {string} volumeName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigMountsVolumesVolumeNameGet: async (instanceId: string, volumeName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigMountsVolumesVolumeNameGet', 'instanceId', instanceId)
            // verify required parameter 'volumeName' is not null or undefined
            assertParamExists('instancesInstanceIdConfigMountsVolumesVolumeNameGet', 'volumeName', volumeName)
            const localVarPath = `/instances/{instance_id}/config/mounts/volumes/{volume_name}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"volume_name"}}`, encodeURIComponent(String(volumeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve connected networks of instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigNetworksGet: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigNetworksGet', 'instanceId', instanceId)
            const localVarPath = `/instances/{instance_id}/config/networks`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove connected network of instance
         * @param {string} instanceId 
         * @param {string} networkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigNetworksNetworkIdDelete: async (instanceId: string, networkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigNetworksNetworkIdDelete', 'instanceId', instanceId)
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigNetworksNetworkIdDelete', 'networkId', networkId)
            const localVarPath = `/instances/{instance_id}/config/networks/{network_id}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve connected network of instance
         * @param {string} instanceId 
         * @param {string} networkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigNetworksNetworkIdGet: async (instanceId: string, networkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigNetworksNetworkIdGet', 'instanceId', instanceId)
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigNetworksNetworkIdGet', 'networkId', networkId)
            const localVarPath = `/instances/{instance_id}/config/networks/{network_id}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Connect instance to network
         * @param {string} instanceId 
         * @param {InstancesInstanceIdConfigNetworksPostRequest} instancesInstanceIdConfigNetworksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigNetworksPost: async (instanceId: string, instancesInstanceIdConfigNetworksPostRequest: InstancesInstanceIdConfigNetworksPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigNetworksPost', 'instanceId', instanceId)
            // verify required parameter 'instancesInstanceIdConfigNetworksPostRequest' is not null or undefined
            assertParamExists('instancesInstanceIdConfigNetworksPost', 'instancesInstanceIdConfigNetworksPostRequest', instancesInstanceIdConfigNetworksPostRequest)
            const localVarPath = `/instances/{instance_id}/config/networks`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(instancesInstanceIdConfigNetworksPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete exposed ports of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigPortsDelete: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPortsDelete', 'instanceId', instanceId)
            const localVarPath = `/instances/{instance_id}/config/ports`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve exposed ports of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigPortsGet: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPortsGet', 'instanceId', instanceId)
            const localVarPath = `/instances/{instance_id}/config/ports`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all published ports of an instance for the given transport_protocol
         * @param {string} instanceId 
         * @param {TransportProtocol} transportProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigPortsTransportProtocolDelete: async (instanceId: string, transportProtocol: TransportProtocol, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPortsTransportProtocolDelete', 'instanceId', instanceId)
            // verify required parameter 'transportProtocol' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPortsTransportProtocolDelete', 'transportProtocol', transportProtocol)
            const localVarPath = `/instances/{instance_id}/config/ports/{transport_protocol}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"transport_protocol"}}`, encodeURIComponent(String(transportProtocol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get published ports of an instance for the given transport_protocol
         * @param {string} instanceId 
         * @param {TransportProtocol} transportProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigPortsTransportProtocolGet: async (instanceId: string, transportProtocol: TransportProtocol, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPortsTransportProtocolGet', 'instanceId', instanceId)
            // verify required parameter 'transportProtocol' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPortsTransportProtocolGet', 'transportProtocol', transportProtocol)
            const localVarPath = `/instances/{instance_id}/config/ports/{transport_protocol}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"transport_protocol"}}`, encodeURIComponent(String(transportProtocol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove instance port range that is mapped to the given host port range
         * @param {string} instanceId 
         * @param {TransportProtocol} transportProtocol 
         * @param {string} hostPortRange 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigPortsTransportProtocolHostPortRangeDelete: async (instanceId: string, transportProtocol: TransportProtocol, hostPortRange: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPortsTransportProtocolHostPortRangeDelete', 'instanceId', instanceId)
            // verify required parameter 'transportProtocol' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPortsTransportProtocolHostPortRangeDelete', 'transportProtocol', transportProtocol)
            // verify required parameter 'hostPortRange' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPortsTransportProtocolHostPortRangeDelete', 'hostPortRange', hostPortRange)
            const localVarPath = `/instances/{instance_id}/config/ports/{transport_protocol}/{host_port_range}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"transport_protocol"}}`, encodeURIComponent(String(transportProtocol)))
                .replace(`{${"host_port_range"}}`, encodeURIComponent(String(hostPortRange)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve instance port range that is mapped to the given host port range
         * @param {string} instanceId 
         * @param {TransportProtocol} transportProtocol 
         * @param {string} hostPortRange 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigPortsTransportProtocolHostPortRangeGet: async (instanceId: string, transportProtocol: TransportProtocol, hostPortRange: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPortsTransportProtocolHostPortRangeGet', 'instanceId', instanceId)
            // verify required parameter 'transportProtocol' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPortsTransportProtocolHostPortRangeGet', 'transportProtocol', transportProtocol)
            // verify required parameter 'hostPortRange' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPortsTransportProtocolHostPortRangeGet', 'hostPortRange', hostPortRange)
            const localVarPath = `/instances/{instance_id}/config/ports/{transport_protocol}/{host_port_range}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"transport_protocol"}}`, encodeURIComponent(String(transportProtocol)))
                .replace(`{${"host_port_range"}}`, encodeURIComponent(String(hostPortRange)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set instance port range that is mapped to the given host port range
         * @param {string} instanceId 
         * @param {TransportProtocol} transportProtocol 
         * @param {string} hostPortRange 
         * @param {InstancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest} instancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigPortsTransportProtocolHostPortRangePut: async (instanceId: string, transportProtocol: TransportProtocol, hostPortRange: string, instancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest: InstancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPortsTransportProtocolHostPortRangePut', 'instanceId', instanceId)
            // verify required parameter 'transportProtocol' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPortsTransportProtocolHostPortRangePut', 'transportProtocol', transportProtocol)
            // verify required parameter 'hostPortRange' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPortsTransportProtocolHostPortRangePut', 'hostPortRange', hostPortRange)
            // verify required parameter 'instancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPortsTransportProtocolHostPortRangePut', 'instancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest', instancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest)
            const localVarPath = `/instances/{instance_id}/config/ports/{transport_protocol}/{host_port_range}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"transport_protocol"}}`, encodeURIComponent(String(transportProtocol)))
                .replace(`{${"host_port_range"}}`, encodeURIComponent(String(hostPortRange)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(instancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update or create published ports of an instance for the given transport protocol
         * @param {string} instanceId 
         * @param {TransportProtocol} transportProtocol 
         * @param {Array<InstancePortMapping>} instancePortMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigPortsTransportProtocolPut: async (instanceId: string, transportProtocol: TransportProtocol, instancePortMapping: Array<InstancePortMapping>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPortsTransportProtocolPut', 'instanceId', instanceId)
            // verify required parameter 'transportProtocol' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPortsTransportProtocolPut', 'transportProtocol', transportProtocol)
            // verify required parameter 'instancePortMapping' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPortsTransportProtocolPut', 'instancePortMapping', instancePortMapping)
            const localVarPath = `/instances/{instance_id}/config/ports/{transport_protocol}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"transport_protocol"}}`, encodeURIComponent(String(transportProtocol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(instancePortMapping, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update configuration of an Instance
         * @param {string} instanceId 
         * @param {InstanceConfig} instanceConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigPost: async (instanceId: string, instanceConfig: InstanceConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPost', 'instanceId', instanceId)
            // verify required parameter 'instanceConfig' is not null or undefined
            assertParamExists('instancesInstanceIdConfigPost', 'instanceConfig', instanceConfig)
            const localVarPath = `/instances/{instance_id}/config`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(instanceConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a single instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdDelete: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdDelete', 'instanceId', instanceId)
            const localVarPath = `/instances/{instance_id}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Access an editor of an app
         * @param {string} instanceId 
         * @param {number} port 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdEditorPortGet: async (instanceId: string, port: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdEditorPortGet', 'instanceId', instanceId)
            // verify required parameter 'port' is not null or undefined
            assertParamExists('instancesInstanceIdEditorPortGet', 'port', port)
            const localVarPath = `/instances/{instance_id}/editor/{port}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"port"}}`, encodeURIComponent(String(port)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Obtain details of an App instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdGet: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdGet', 'instanceId', instanceId)
            const localVarPath = `/instances/{instance_id}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve logs of an Instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdLogsGet: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdLogsGet', 'instanceId', instanceId)
            const localVarPath = `/instances/{instance_id}/logs`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update or downgrade Instance to another App version
         * @param {string} instanceId 
         * @param {InstancesInstanceIdPatchRequest} instancesInstanceIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdPatch: async (instanceId: string, instancesInstanceIdPatchRequest: InstancesInstanceIdPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdPatch', 'instanceId', instanceId)
            // verify required parameter 'instancesInstanceIdPatchRequest' is not null or undefined
            assertParamExists('instancesInstanceIdPatch', 'instancesInstanceIdPatchRequest', instancesInstanceIdPatchRequest)
            const localVarPath = `/instances/{instance_id}`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(instancesInstanceIdPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start an App instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdStartPost: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdStartPost', 'instanceId', instanceId)
            const localVarPath = `/instances/{instance_id}/start`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop an App instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdStopPost: async (instanceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('instancesInstanceIdStopPost', 'instanceId', instanceId)
            const localVarPath = `/instances/{instance_id}/stop`
                .replace(`{${"instance_id"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InstancesApi - functional programming interface
 * @export
 */
export const InstancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InstancesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create new instance of an installed App
         * @param {InstancesCreatePostRequest} instancesCreatePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesCreatePost(instancesCreatePostRequest: InstancesCreatePostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesCreatePost(instancesCreatePostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Query all instances of one or all Apps
         * @param {string} [app] 
         * @param {string} [version] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesGet(app?: string, version?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AppInstance>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesGet(app, version, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove all passed through usb devices of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigDevicesUsbDelete(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigDevicesUsbDelete(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigDevicesUsbDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve passed through usb devices of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigDevicesUsbGet(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InstanceConfigUsbDevice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigDevicesUsbGet(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigDevicesUsbGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete passed through usb device of the instance with the given port
         * @param {string} instanceId 
         * @param {string} port 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigDevicesUsbPortDelete(instanceId: string, port: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigDevicesUsbPortDelete(instanceId, port, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigDevicesUsbPortDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve passed through usb device of the instance with the given port
         * @param {string} instanceId 
         * @param {string} port 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigDevicesUsbPortGet(instanceId: string, port: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceConfigUsbDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigDevicesUsbPortGet(instanceId, port, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigDevicesUsbPortGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Pass through usb device with the given port to the instance
         * @param {string} instanceId 
         * @param {string} port 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigDevicesUsbPortPut(instanceId: string, port: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigDevicesUsbPortPut(instanceId, port, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigDevicesUsbPortPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete environment of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigEnvironmentDelete(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigEnvironmentDelete(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigEnvironmentDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve environment of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigEnvironmentGet(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InstanceEnvironmentVariable>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigEnvironmentGet(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigEnvironmentGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Modify or create environment of an instance
         * @param {string} instanceId 
         * @param {Array<InstanceEnvironmentVariable>} instanceEnvironmentVariable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigEnvironmentPut(instanceId: string, instanceEnvironmentVariable: Array<InstanceEnvironmentVariable>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigEnvironmentPut(instanceId, instanceEnvironmentVariable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigEnvironmentPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove an environment variable of an instance
         * @param {string} instanceId 
         * @param {string} variableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigEnvironmentVariableNameDelete(instanceId: string, variableName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigEnvironmentVariableNameDelete(instanceId, variableName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigEnvironmentVariableNameDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve the value of an environment variable
         * @param {string} instanceId 
         * @param {string} variableName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigEnvironmentVariableNameGet(instanceId: string, variableName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstancesInstanceIdConfigEnvironmentVariableNameGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigEnvironmentVariableNameGet(instanceId, variableName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigEnvironmentVariableNameGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set the value of an environment variable of an instance
         * @param {string} instanceId 
         * @param {string} variableName 
         * @param {InstancesInstanceIdConfigEnvironmentVariableNameGet200Response} instancesInstanceIdConfigEnvironmentVariableNameGet200Response 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigEnvironmentVariableNamePut(instanceId: string, variableName: string, instancesInstanceIdConfigEnvironmentVariableNameGet200Response: InstancesInstanceIdConfigEnvironmentVariableNameGet200Response, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigEnvironmentVariableNamePut(instanceId, variableName, instancesInstanceIdConfigEnvironmentVariableNameGet200Response, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigEnvironmentVariableNamePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get configuration of an Instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigGet(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigGet(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve labels of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigLabelsGet(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InstanceLabel>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigLabelsGet(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigLabelsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve value of a specific label of an instance
         * @param {string} instanceId 
         * @param {string} labelName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigLabelsLabelNameGet(instanceId: string, labelName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstancesInstanceIdConfigLabelsLabelNameGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigLabelsLabelNameGet(instanceId, labelName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigLabelsLabelNameGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve bind mount of an instance
         * @param {string} instanceId 
         * @param {string} containerPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigMountsBindContainerPathGet(instanceId: string, containerPath: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BindMount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigMountsBindContainerPathGet(instanceId, containerPath, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigMountsBindContainerPathGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve bind mounts of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigMountsBindGet(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BindMount>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigMountsBindGet(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigMountsBindGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve volumes of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigMountsGet(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Mounts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigMountsGet(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigMountsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve volumes mounts of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigMountsVolumesGet(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InstanceDetailVolume>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigMountsVolumesGet(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigMountsVolumesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve volume mount of an instance
         * @param {string} instanceId 
         * @param {string} volumeName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigMountsVolumesVolumeNameGet(instanceId: string, volumeName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceDetailVolume>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigMountsVolumesVolumeNameGet(instanceId, volumeName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigMountsVolumesVolumeNameGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve connected networks of instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigNetworksGet(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InstanceConfigNetwork>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigNetworksGet(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigNetworksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove connected network of instance
         * @param {string} instanceId 
         * @param {string} networkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigNetworksNetworkIdDelete(instanceId: string, networkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigNetworksNetworkIdDelete(instanceId, networkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigNetworksNetworkIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve connected network of instance
         * @param {string} instanceId 
         * @param {string} networkId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigNetworksNetworkIdGet(instanceId: string, networkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceConfigNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigNetworksNetworkIdGet(instanceId, networkId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigNetworksNetworkIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Connect instance to network
         * @param {string} instanceId 
         * @param {InstancesInstanceIdConfigNetworksPostRequest} instancesInstanceIdConfigNetworksPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigNetworksPost(instanceId: string, instancesInstanceIdConfigNetworksPostRequest: InstancesInstanceIdConfigNetworksPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigNetworksPost(instanceId, instancesInstanceIdConfigNetworksPostRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigNetworksPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete exposed ports of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigPortsDelete(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigPortsDelete(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigPortsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve exposed ports of an instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigPortsGet(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstancePorts>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigPortsGet(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigPortsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove all published ports of an instance for the given transport_protocol
         * @param {string} instanceId 
         * @param {TransportProtocol} transportProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigPortsTransportProtocolDelete(instanceId: string, transportProtocol: TransportProtocol, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigPortsTransportProtocolDelete(instanceId, transportProtocol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigPortsTransportProtocolDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get published ports of an instance for the given transport_protocol
         * @param {string} instanceId 
         * @param {TransportProtocol} transportProtocol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigPortsTransportProtocolGet(instanceId: string, transportProtocol: TransportProtocol, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InstancePortMapping>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigPortsTransportProtocolGet(instanceId, transportProtocol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigPortsTransportProtocolGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove instance port range that is mapped to the given host port range
         * @param {string} instanceId 
         * @param {TransportProtocol} transportProtocol 
         * @param {string} hostPortRange 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigPortsTransportProtocolHostPortRangeDelete(instanceId: string, transportProtocol: TransportProtocol, hostPortRange: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigPortsTransportProtocolHostPortRangeDelete(instanceId, transportProtocol, hostPortRange, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigPortsTransportProtocolHostPortRangeDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve instance port range that is mapped to the given host port range
         * @param {string} instanceId 
         * @param {TransportProtocol} transportProtocol 
         * @param {string} hostPortRange 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigPortsTransportProtocolHostPortRangeGet(instanceId: string, transportProtocol: TransportProtocol, hostPortRange: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstancePortMapping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigPortsTransportProtocolHostPortRangeGet(instanceId, transportProtocol, hostPortRange, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigPortsTransportProtocolHostPortRangeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Set instance port range that is mapped to the given host port range
         * @param {string} instanceId 
         * @param {TransportProtocol} transportProtocol 
         * @param {string} hostPortRange 
         * @param {InstancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest} instancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigPortsTransportProtocolHostPortRangePut(instanceId: string, transportProtocol: TransportProtocol, hostPortRange: string, instancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest: InstancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigPortsTransportProtocolHostPortRangePut(instanceId, transportProtocol, hostPortRange, instancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigPortsTransportProtocolHostPortRangePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update or create published ports of an instance for the given transport protocol
         * @param {string} instanceId 
         * @param {TransportProtocol} transportProtocol 
         * @param {Array<InstancePortMapping>} instancePortMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigPortsTransportProtocolPut(instanceId: string, transportProtocol: TransportProtocol, instancePortMapping: Array<InstancePortMapping>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigPortsTransportProtocolPut(instanceId, transportProtocol, instancePortMapping, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigPortsTransportProtocolPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update configuration of an Instance
         * @param {string} instanceId 
         * @param {InstanceConfig} instanceConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdConfigPost(instanceId: string, instanceConfig: InstanceConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstanceConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdConfigPost(instanceId, instanceConfig, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdConfigPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a single instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdDelete(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdDelete(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Access an editor of an app
         * @param {string} instanceId 
         * @param {number} port 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdEditorPortGet(instanceId: string, port: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdEditorPortGet(instanceId, port, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdEditorPortGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Obtain details of an App instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdGet(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstancesInstanceIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdGet(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve logs of an Instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdLogsGet(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstancesInstanceIdLogsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdLogsGet(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdLogsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update or downgrade Instance to another App version
         * @param {string} instanceId 
         * @param {InstancesInstanceIdPatchRequest} instancesInstanceIdPatchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdPatch(instanceId: string, instancesInstanceIdPatchRequest: InstancesInstanceIdPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdPatch(instanceId, instancesInstanceIdPatchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdPatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Start an App instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdStartPost(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdStartPost(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdStartPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Stop an App instance
         * @param {string} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async instancesInstanceIdStopPost(instanceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobMeta>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.instancesInstanceIdStopPost(instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InstancesApi.instancesInstanceIdStopPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InstancesApi - factory interface
 * @export
 */
export const InstancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InstancesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create new instance of an installed App
         * @param {InstancesApiInstancesCreatePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesCreatePost(requestParameters: InstancesApiInstancesCreatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobMeta> {
            return localVarFp.instancesCreatePost(requestParameters.instancesCreatePostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Query all instances of one or all Apps
         * @param {InstancesApiInstancesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesGet(requestParameters: InstancesApiInstancesGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<AppInstance>> {
            return localVarFp.instancesGet(requestParameters.app, requestParameters.version, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all passed through usb devices of an instance
         * @param {InstancesApiInstancesInstanceIdConfigDevicesUsbDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigDevicesUsbDelete(requestParameters: InstancesApiInstancesInstanceIdConfigDevicesUsbDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.instancesInstanceIdConfigDevicesUsbDelete(requestParameters.instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve passed through usb devices of an instance
         * @param {InstancesApiInstancesInstanceIdConfigDevicesUsbGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigDevicesUsbGet(requestParameters: InstancesApiInstancesInstanceIdConfigDevicesUsbGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<InstanceConfigUsbDevice>> {
            return localVarFp.instancesInstanceIdConfigDevicesUsbGet(requestParameters.instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete passed through usb device of the instance with the given port
         * @param {InstancesApiInstancesInstanceIdConfigDevicesUsbPortDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigDevicesUsbPortDelete(requestParameters: InstancesApiInstancesInstanceIdConfigDevicesUsbPortDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.instancesInstanceIdConfigDevicesUsbPortDelete(requestParameters.instanceId, requestParameters.port, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve passed through usb device of the instance with the given port
         * @param {InstancesApiInstancesInstanceIdConfigDevicesUsbPortGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigDevicesUsbPortGet(requestParameters: InstancesApiInstancesInstanceIdConfigDevicesUsbPortGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstanceConfigUsbDevice> {
            return localVarFp.instancesInstanceIdConfigDevicesUsbPortGet(requestParameters.instanceId, requestParameters.port, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pass through usb device with the given port to the instance
         * @param {InstancesApiInstancesInstanceIdConfigDevicesUsbPortPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigDevicesUsbPortPut(requestParameters: InstancesApiInstancesInstanceIdConfigDevicesUsbPortPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.instancesInstanceIdConfigDevicesUsbPortPut(requestParameters.instanceId, requestParameters.port, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete environment of an instance
         * @param {InstancesApiInstancesInstanceIdConfigEnvironmentDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigEnvironmentDelete(requestParameters: InstancesApiInstancesInstanceIdConfigEnvironmentDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.instancesInstanceIdConfigEnvironmentDelete(requestParameters.instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve environment of an instance
         * @param {InstancesApiInstancesInstanceIdConfigEnvironmentGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigEnvironmentGet(requestParameters: InstancesApiInstancesInstanceIdConfigEnvironmentGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<InstanceEnvironmentVariable>> {
            return localVarFp.instancesInstanceIdConfigEnvironmentGet(requestParameters.instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Modify or create environment of an instance
         * @param {InstancesApiInstancesInstanceIdConfigEnvironmentPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigEnvironmentPut(requestParameters: InstancesApiInstancesInstanceIdConfigEnvironmentPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.instancesInstanceIdConfigEnvironmentPut(requestParameters.instanceId, requestParameters.instanceEnvironmentVariable, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an environment variable of an instance
         * @param {InstancesApiInstancesInstanceIdConfigEnvironmentVariableNameDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigEnvironmentVariableNameDelete(requestParameters: InstancesApiInstancesInstanceIdConfigEnvironmentVariableNameDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.instancesInstanceIdConfigEnvironmentVariableNameDelete(requestParameters.instanceId, requestParameters.variableName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve the value of an environment variable
         * @param {InstancesApiInstancesInstanceIdConfigEnvironmentVariableNameGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigEnvironmentVariableNameGet(requestParameters: InstancesApiInstancesInstanceIdConfigEnvironmentVariableNameGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstancesInstanceIdConfigEnvironmentVariableNameGet200Response> {
            return localVarFp.instancesInstanceIdConfigEnvironmentVariableNameGet(requestParameters.instanceId, requestParameters.variableName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set the value of an environment variable of an instance
         * @param {InstancesApiInstancesInstanceIdConfigEnvironmentVariableNamePutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigEnvironmentVariableNamePut(requestParameters: InstancesApiInstancesInstanceIdConfigEnvironmentVariableNamePutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.instancesInstanceIdConfigEnvironmentVariableNamePut(requestParameters.instanceId, requestParameters.variableName, requestParameters.instancesInstanceIdConfigEnvironmentVariableNameGet200Response, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get configuration of an Instance
         * @param {InstancesApiInstancesInstanceIdConfigGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigGet(requestParameters: InstancesApiInstancesInstanceIdConfigGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstanceConfig> {
            return localVarFp.instancesInstanceIdConfigGet(requestParameters.instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve labels of an instance
         * @param {InstancesApiInstancesInstanceIdConfigLabelsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigLabelsGet(requestParameters: InstancesApiInstancesInstanceIdConfigLabelsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<InstanceLabel>> {
            return localVarFp.instancesInstanceIdConfigLabelsGet(requestParameters.instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve value of a specific label of an instance
         * @param {InstancesApiInstancesInstanceIdConfigLabelsLabelNameGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigLabelsLabelNameGet(requestParameters: InstancesApiInstancesInstanceIdConfigLabelsLabelNameGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstancesInstanceIdConfigLabelsLabelNameGet200Response> {
            return localVarFp.instancesInstanceIdConfigLabelsLabelNameGet(requestParameters.instanceId, requestParameters.labelName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve bind mount of an instance
         * @param {InstancesApiInstancesInstanceIdConfigMountsBindContainerPathGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigMountsBindContainerPathGet(requestParameters: InstancesApiInstancesInstanceIdConfigMountsBindContainerPathGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<BindMount> {
            return localVarFp.instancesInstanceIdConfigMountsBindContainerPathGet(requestParameters.instanceId, requestParameters.containerPath, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve bind mounts of an instance
         * @param {InstancesApiInstancesInstanceIdConfigMountsBindGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigMountsBindGet(requestParameters: InstancesApiInstancesInstanceIdConfigMountsBindGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<BindMount>> {
            return localVarFp.instancesInstanceIdConfigMountsBindGet(requestParameters.instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve volumes of an instance
         * @param {InstancesApiInstancesInstanceIdConfigMountsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigMountsGet(requestParameters: InstancesApiInstancesInstanceIdConfigMountsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Mounts> {
            return localVarFp.instancesInstanceIdConfigMountsGet(requestParameters.instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve volumes mounts of an instance
         * @param {InstancesApiInstancesInstanceIdConfigMountsVolumesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigMountsVolumesGet(requestParameters: InstancesApiInstancesInstanceIdConfigMountsVolumesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<InstanceDetailVolume>> {
            return localVarFp.instancesInstanceIdConfigMountsVolumesGet(requestParameters.instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve volume mount of an instance
         * @param {InstancesApiInstancesInstanceIdConfigMountsVolumesVolumeNameGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigMountsVolumesVolumeNameGet(requestParameters: InstancesApiInstancesInstanceIdConfigMountsVolumesVolumeNameGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstanceDetailVolume> {
            return localVarFp.instancesInstanceIdConfigMountsVolumesVolumeNameGet(requestParameters.instanceId, requestParameters.volumeName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve connected networks of instance
         * @param {InstancesApiInstancesInstanceIdConfigNetworksGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigNetworksGet(requestParameters: InstancesApiInstancesInstanceIdConfigNetworksGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<InstanceConfigNetwork>> {
            return localVarFp.instancesInstanceIdConfigNetworksGet(requestParameters.instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove connected network of instance
         * @param {InstancesApiInstancesInstanceIdConfigNetworksNetworkIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigNetworksNetworkIdDelete(requestParameters: InstancesApiInstancesInstanceIdConfigNetworksNetworkIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.instancesInstanceIdConfigNetworksNetworkIdDelete(requestParameters.instanceId, requestParameters.networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve connected network of instance
         * @param {InstancesApiInstancesInstanceIdConfigNetworksNetworkIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigNetworksNetworkIdGet(requestParameters: InstancesApiInstancesInstanceIdConfigNetworksNetworkIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstanceConfigNetwork> {
            return localVarFp.instancesInstanceIdConfigNetworksNetworkIdGet(requestParameters.instanceId, requestParameters.networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Connect instance to network
         * @param {InstancesApiInstancesInstanceIdConfigNetworksPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigNetworksPost(requestParameters: InstancesApiInstancesInstanceIdConfigNetworksPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.instancesInstanceIdConfigNetworksPost(requestParameters.instanceId, requestParameters.instancesInstanceIdConfigNetworksPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete exposed ports of an instance
         * @param {InstancesApiInstancesInstanceIdConfigPortsDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigPortsDelete(requestParameters: InstancesApiInstancesInstanceIdConfigPortsDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.instancesInstanceIdConfigPortsDelete(requestParameters.instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve exposed ports of an instance
         * @param {InstancesApiInstancesInstanceIdConfigPortsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigPortsGet(requestParameters: InstancesApiInstancesInstanceIdConfigPortsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstancePorts> {
            return localVarFp.instancesInstanceIdConfigPortsGet(requestParameters.instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all published ports of an instance for the given transport_protocol
         * @param {InstancesApiInstancesInstanceIdConfigPortsTransportProtocolDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigPortsTransportProtocolDelete(requestParameters: InstancesApiInstancesInstanceIdConfigPortsTransportProtocolDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.instancesInstanceIdConfigPortsTransportProtocolDelete(requestParameters.instanceId, requestParameters.transportProtocol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get published ports of an instance for the given transport_protocol
         * @param {InstancesApiInstancesInstanceIdConfigPortsTransportProtocolGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigPortsTransportProtocolGet(requestParameters: InstancesApiInstancesInstanceIdConfigPortsTransportProtocolGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<InstancePortMapping>> {
            return localVarFp.instancesInstanceIdConfigPortsTransportProtocolGet(requestParameters.instanceId, requestParameters.transportProtocol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove instance port range that is mapped to the given host port range
         * @param {InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangeDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigPortsTransportProtocolHostPortRangeDelete(requestParameters: InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangeDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.instancesInstanceIdConfigPortsTransportProtocolHostPortRangeDelete(requestParameters.instanceId, requestParameters.transportProtocol, requestParameters.hostPortRange, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve instance port range that is mapped to the given host port range
         * @param {InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangeGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigPortsTransportProtocolHostPortRangeGet(requestParameters: InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangeGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstancePortMapping> {
            return localVarFp.instancesInstanceIdConfigPortsTransportProtocolHostPortRangeGet(requestParameters.instanceId, requestParameters.transportProtocol, requestParameters.hostPortRange, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set instance port range that is mapped to the given host port range
         * @param {InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigPortsTransportProtocolHostPortRangePut(requestParameters: InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.instancesInstanceIdConfigPortsTransportProtocolHostPortRangePut(requestParameters.instanceId, requestParameters.transportProtocol, requestParameters.hostPortRange, requestParameters.instancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update or create published ports of an instance for the given transport protocol
         * @param {InstancesApiInstancesInstanceIdConfigPortsTransportProtocolPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigPortsTransportProtocolPut(requestParameters: InstancesApiInstancesInstanceIdConfigPortsTransportProtocolPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.instancesInstanceIdConfigPortsTransportProtocolPut(requestParameters.instanceId, requestParameters.transportProtocol, requestParameters.instancePortMapping, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update configuration of an Instance
         * @param {InstancesApiInstancesInstanceIdConfigPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdConfigPost(requestParameters: InstancesApiInstancesInstanceIdConfigPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstanceConfig> {
            return localVarFp.instancesInstanceIdConfigPost(requestParameters.instanceId, requestParameters.instanceConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a single instance
         * @param {InstancesApiInstancesInstanceIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdDelete(requestParameters: InstancesApiInstancesInstanceIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobMeta> {
            return localVarFp.instancesInstanceIdDelete(requestParameters.instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Access an editor of an app
         * @param {InstancesApiInstancesInstanceIdEditorPortGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdEditorPortGet(requestParameters: InstancesApiInstancesInstanceIdEditorPortGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.instancesInstanceIdEditorPortGet(requestParameters.instanceId, requestParameters.port, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Obtain details of an App instance
         * @param {InstancesApiInstancesInstanceIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdGet(requestParameters: InstancesApiInstancesInstanceIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstancesInstanceIdGet200Response> {
            return localVarFp.instancesInstanceIdGet(requestParameters.instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve logs of an Instance
         * @param {InstancesApiInstancesInstanceIdLogsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdLogsGet(requestParameters: InstancesApiInstancesInstanceIdLogsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<InstancesInstanceIdLogsGet200Response> {
            return localVarFp.instancesInstanceIdLogsGet(requestParameters.instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update or downgrade Instance to another App version
         * @param {InstancesApiInstancesInstanceIdPatchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdPatch(requestParameters: InstancesApiInstancesInstanceIdPatchRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobMeta> {
            return localVarFp.instancesInstanceIdPatch(requestParameters.instanceId, requestParameters.instancesInstanceIdPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start an App instance
         * @param {InstancesApiInstancesInstanceIdStartPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdStartPost(requestParameters: InstancesApiInstancesInstanceIdStartPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobMeta> {
            return localVarFp.instancesInstanceIdStartPost(requestParameters.instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop an App instance
         * @param {InstancesApiInstancesInstanceIdStopPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        instancesInstanceIdStopPost(requestParameters: InstancesApiInstancesInstanceIdStopPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobMeta> {
            return localVarFp.instancesInstanceIdStopPost(requestParameters.instanceId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for instancesCreatePost operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesCreatePostRequest
 */
export interface InstancesApiInstancesCreatePostRequest {
    /**
     * 
     * @type {InstancesCreatePostRequest}
     * @memberof InstancesApiInstancesCreatePost
     */
    readonly instancesCreatePostRequest: InstancesCreatePostRequest
}

/**
 * Request parameters for instancesGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesGetRequest
 */
export interface InstancesApiInstancesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesGet
     */
    readonly app?: string

    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesGet
     */
    readonly version?: string
}

/**
 * Request parameters for instancesInstanceIdConfigDevicesUsbDelete operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigDevicesUsbDeleteRequest
 */
export interface InstancesApiInstancesInstanceIdConfigDevicesUsbDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigDevicesUsbDelete
     */
    readonly instanceId: string
}

/**
 * Request parameters for instancesInstanceIdConfigDevicesUsbGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigDevicesUsbGetRequest
 */
export interface InstancesApiInstancesInstanceIdConfigDevicesUsbGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigDevicesUsbGet
     */
    readonly instanceId: string
}

/**
 * Request parameters for instancesInstanceIdConfigDevicesUsbPortDelete operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigDevicesUsbPortDeleteRequest
 */
export interface InstancesApiInstancesInstanceIdConfigDevicesUsbPortDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigDevicesUsbPortDelete
     */
    readonly instanceId: string

    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigDevicesUsbPortDelete
     */
    readonly port: string
}

/**
 * Request parameters for instancesInstanceIdConfigDevicesUsbPortGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigDevicesUsbPortGetRequest
 */
export interface InstancesApiInstancesInstanceIdConfigDevicesUsbPortGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigDevicesUsbPortGet
     */
    readonly instanceId: string

    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigDevicesUsbPortGet
     */
    readonly port: string
}

/**
 * Request parameters for instancesInstanceIdConfigDevicesUsbPortPut operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigDevicesUsbPortPutRequest
 */
export interface InstancesApiInstancesInstanceIdConfigDevicesUsbPortPutRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigDevicesUsbPortPut
     */
    readonly instanceId: string

    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigDevicesUsbPortPut
     */
    readonly port: string
}

/**
 * Request parameters for instancesInstanceIdConfigEnvironmentDelete operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigEnvironmentDeleteRequest
 */
export interface InstancesApiInstancesInstanceIdConfigEnvironmentDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigEnvironmentDelete
     */
    readonly instanceId: string
}

/**
 * Request parameters for instancesInstanceIdConfigEnvironmentGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigEnvironmentGetRequest
 */
export interface InstancesApiInstancesInstanceIdConfigEnvironmentGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigEnvironmentGet
     */
    readonly instanceId: string
}

/**
 * Request parameters for instancesInstanceIdConfigEnvironmentPut operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigEnvironmentPutRequest
 */
export interface InstancesApiInstancesInstanceIdConfigEnvironmentPutRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigEnvironmentPut
     */
    readonly instanceId: string

    /**
     * 
     * @type {Array<InstanceEnvironmentVariable>}
     * @memberof InstancesApiInstancesInstanceIdConfigEnvironmentPut
     */
    readonly instanceEnvironmentVariable: Array<InstanceEnvironmentVariable>
}

/**
 * Request parameters for instancesInstanceIdConfigEnvironmentVariableNameDelete operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigEnvironmentVariableNameDeleteRequest
 */
export interface InstancesApiInstancesInstanceIdConfigEnvironmentVariableNameDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigEnvironmentVariableNameDelete
     */
    readonly instanceId: string

    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigEnvironmentVariableNameDelete
     */
    readonly variableName: string
}

/**
 * Request parameters for instancesInstanceIdConfigEnvironmentVariableNameGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigEnvironmentVariableNameGetRequest
 */
export interface InstancesApiInstancesInstanceIdConfigEnvironmentVariableNameGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigEnvironmentVariableNameGet
     */
    readonly instanceId: string

    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigEnvironmentVariableNameGet
     */
    readonly variableName: string
}

/**
 * Request parameters for instancesInstanceIdConfigEnvironmentVariableNamePut operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigEnvironmentVariableNamePutRequest
 */
export interface InstancesApiInstancesInstanceIdConfigEnvironmentVariableNamePutRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigEnvironmentVariableNamePut
     */
    readonly instanceId: string

    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigEnvironmentVariableNamePut
     */
    readonly variableName: string

    /**
     * 
     * @type {InstancesInstanceIdConfigEnvironmentVariableNameGet200Response}
     * @memberof InstancesApiInstancesInstanceIdConfigEnvironmentVariableNamePut
     */
    readonly instancesInstanceIdConfigEnvironmentVariableNameGet200Response: InstancesInstanceIdConfigEnvironmentVariableNameGet200Response
}

/**
 * Request parameters for instancesInstanceIdConfigGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigGetRequest
 */
export interface InstancesApiInstancesInstanceIdConfigGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigGet
     */
    readonly instanceId: string
}

/**
 * Request parameters for instancesInstanceIdConfigLabelsGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigLabelsGetRequest
 */
export interface InstancesApiInstancesInstanceIdConfigLabelsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigLabelsGet
     */
    readonly instanceId: string
}

/**
 * Request parameters for instancesInstanceIdConfigLabelsLabelNameGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigLabelsLabelNameGetRequest
 */
export interface InstancesApiInstancesInstanceIdConfigLabelsLabelNameGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigLabelsLabelNameGet
     */
    readonly instanceId: string

    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigLabelsLabelNameGet
     */
    readonly labelName: string
}

/**
 * Request parameters for instancesInstanceIdConfigMountsBindContainerPathGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigMountsBindContainerPathGetRequest
 */
export interface InstancesApiInstancesInstanceIdConfigMountsBindContainerPathGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigMountsBindContainerPathGet
     */
    readonly instanceId: string

    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigMountsBindContainerPathGet
     */
    readonly containerPath: string
}

/**
 * Request parameters for instancesInstanceIdConfigMountsBindGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigMountsBindGetRequest
 */
export interface InstancesApiInstancesInstanceIdConfigMountsBindGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigMountsBindGet
     */
    readonly instanceId: string
}

/**
 * Request parameters for instancesInstanceIdConfigMountsGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigMountsGetRequest
 */
export interface InstancesApiInstancesInstanceIdConfigMountsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigMountsGet
     */
    readonly instanceId: string
}

/**
 * Request parameters for instancesInstanceIdConfigMountsVolumesGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigMountsVolumesGetRequest
 */
export interface InstancesApiInstancesInstanceIdConfigMountsVolumesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigMountsVolumesGet
     */
    readonly instanceId: string
}

/**
 * Request parameters for instancesInstanceIdConfigMountsVolumesVolumeNameGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigMountsVolumesVolumeNameGetRequest
 */
export interface InstancesApiInstancesInstanceIdConfigMountsVolumesVolumeNameGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigMountsVolumesVolumeNameGet
     */
    readonly instanceId: string

    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigMountsVolumesVolumeNameGet
     */
    readonly volumeName: string
}

/**
 * Request parameters for instancesInstanceIdConfigNetworksGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigNetworksGetRequest
 */
export interface InstancesApiInstancesInstanceIdConfigNetworksGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigNetworksGet
     */
    readonly instanceId: string
}

/**
 * Request parameters for instancesInstanceIdConfigNetworksNetworkIdDelete operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigNetworksNetworkIdDeleteRequest
 */
export interface InstancesApiInstancesInstanceIdConfigNetworksNetworkIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigNetworksNetworkIdDelete
     */
    readonly instanceId: string

    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigNetworksNetworkIdDelete
     */
    readonly networkId: string
}

/**
 * Request parameters for instancesInstanceIdConfigNetworksNetworkIdGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigNetworksNetworkIdGetRequest
 */
export interface InstancesApiInstancesInstanceIdConfigNetworksNetworkIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigNetworksNetworkIdGet
     */
    readonly instanceId: string

    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigNetworksNetworkIdGet
     */
    readonly networkId: string
}

/**
 * Request parameters for instancesInstanceIdConfigNetworksPost operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigNetworksPostRequest
 */
export interface InstancesApiInstancesInstanceIdConfigNetworksPostRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigNetworksPost
     */
    readonly instanceId: string

    /**
     * 
     * @type {InstancesInstanceIdConfigNetworksPostRequest}
     * @memberof InstancesApiInstancesInstanceIdConfigNetworksPost
     */
    readonly instancesInstanceIdConfigNetworksPostRequest: InstancesInstanceIdConfigNetworksPostRequest
}

/**
 * Request parameters for instancesInstanceIdConfigPortsDelete operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigPortsDeleteRequest
 */
export interface InstancesApiInstancesInstanceIdConfigPortsDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigPortsDelete
     */
    readonly instanceId: string
}

/**
 * Request parameters for instancesInstanceIdConfigPortsGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigPortsGetRequest
 */
export interface InstancesApiInstancesInstanceIdConfigPortsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigPortsGet
     */
    readonly instanceId: string
}

/**
 * Request parameters for instancesInstanceIdConfigPortsTransportProtocolDelete operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigPortsTransportProtocolDeleteRequest
 */
export interface InstancesApiInstancesInstanceIdConfigPortsTransportProtocolDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigPortsTransportProtocolDelete
     */
    readonly instanceId: string

    /**
     * 
     * @type {TransportProtocol}
     * @memberof InstancesApiInstancesInstanceIdConfigPortsTransportProtocolDelete
     */
    readonly transportProtocol: TransportProtocol
}

/**
 * Request parameters for instancesInstanceIdConfigPortsTransportProtocolGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigPortsTransportProtocolGetRequest
 */
export interface InstancesApiInstancesInstanceIdConfigPortsTransportProtocolGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigPortsTransportProtocolGet
     */
    readonly instanceId: string

    /**
     * 
     * @type {TransportProtocol}
     * @memberof InstancesApiInstancesInstanceIdConfigPortsTransportProtocolGet
     */
    readonly transportProtocol: TransportProtocol
}

/**
 * Request parameters for instancesInstanceIdConfigPortsTransportProtocolHostPortRangeDelete operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangeDeleteRequest
 */
export interface InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangeDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangeDelete
     */
    readonly instanceId: string

    /**
     * 
     * @type {TransportProtocol}
     * @memberof InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangeDelete
     */
    readonly transportProtocol: TransportProtocol

    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangeDelete
     */
    readonly hostPortRange: string
}

/**
 * Request parameters for instancesInstanceIdConfigPortsTransportProtocolHostPortRangeGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangeGetRequest
 */
export interface InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangeGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangeGet
     */
    readonly instanceId: string

    /**
     * 
     * @type {TransportProtocol}
     * @memberof InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangeGet
     */
    readonly transportProtocol: TransportProtocol

    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangeGet
     */
    readonly hostPortRange: string
}

/**
 * Request parameters for instancesInstanceIdConfigPortsTransportProtocolHostPortRangePut operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest
 */
export interface InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangePut
     */
    readonly instanceId: string

    /**
     * 
     * @type {TransportProtocol}
     * @memberof InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangePut
     */
    readonly transportProtocol: TransportProtocol

    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangePut
     */
    readonly hostPortRange: string

    /**
     * 
     * @type {InstancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest}
     * @memberof InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangePut
     */
    readonly instancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest: InstancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest
}

/**
 * Request parameters for instancesInstanceIdConfigPortsTransportProtocolPut operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigPortsTransportProtocolPutRequest
 */
export interface InstancesApiInstancesInstanceIdConfigPortsTransportProtocolPutRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigPortsTransportProtocolPut
     */
    readonly instanceId: string

    /**
     * 
     * @type {TransportProtocol}
     * @memberof InstancesApiInstancesInstanceIdConfigPortsTransportProtocolPut
     */
    readonly transportProtocol: TransportProtocol

    /**
     * 
     * @type {Array<InstancePortMapping>}
     * @memberof InstancesApiInstancesInstanceIdConfigPortsTransportProtocolPut
     */
    readonly instancePortMapping: Array<InstancePortMapping>
}

/**
 * Request parameters for instancesInstanceIdConfigPost operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdConfigPostRequest
 */
export interface InstancesApiInstancesInstanceIdConfigPostRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdConfigPost
     */
    readonly instanceId: string

    /**
     * 
     * @type {InstanceConfig}
     * @memberof InstancesApiInstancesInstanceIdConfigPost
     */
    readonly instanceConfig: InstanceConfig
}

/**
 * Request parameters for instancesInstanceIdDelete operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdDeleteRequest
 */
export interface InstancesApiInstancesInstanceIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdDelete
     */
    readonly instanceId: string
}

/**
 * Request parameters for instancesInstanceIdEditorPortGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdEditorPortGetRequest
 */
export interface InstancesApiInstancesInstanceIdEditorPortGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdEditorPortGet
     */
    readonly instanceId: string

    /**
     * 
     * @type {number}
     * @memberof InstancesApiInstancesInstanceIdEditorPortGet
     */
    readonly port: number
}

/**
 * Request parameters for instancesInstanceIdGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdGetRequest
 */
export interface InstancesApiInstancesInstanceIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdGet
     */
    readonly instanceId: string
}

/**
 * Request parameters for instancesInstanceIdLogsGet operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdLogsGetRequest
 */
export interface InstancesApiInstancesInstanceIdLogsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdLogsGet
     */
    readonly instanceId: string
}

/**
 * Request parameters for instancesInstanceIdPatch operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdPatchRequest
 */
export interface InstancesApiInstancesInstanceIdPatchRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdPatch
     */
    readonly instanceId: string

    /**
     * 
     * @type {InstancesInstanceIdPatchRequest}
     * @memberof InstancesApiInstancesInstanceIdPatch
     */
    readonly instancesInstanceIdPatchRequest: InstancesInstanceIdPatchRequest
}

/**
 * Request parameters for instancesInstanceIdStartPost operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdStartPostRequest
 */
export interface InstancesApiInstancesInstanceIdStartPostRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdStartPost
     */
    readonly instanceId: string
}

/**
 * Request parameters for instancesInstanceIdStopPost operation in InstancesApi.
 * @export
 * @interface InstancesApiInstancesInstanceIdStopPostRequest
 */
export interface InstancesApiInstancesInstanceIdStopPostRequest {
    /**
     * 
     * @type {string}
     * @memberof InstancesApiInstancesInstanceIdStopPost
     */
    readonly instanceId: string
}

/**
 * InstancesApi - object-oriented interface
 * @export
 * @class InstancesApi
 * @extends {BaseAPI}
 */
export class InstancesApi extends BaseAPI {
    /**
     * 
     * @summary Create new instance of an installed App
     * @param {InstancesApiInstancesCreatePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesCreatePost(requestParameters: InstancesApiInstancesCreatePostRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesCreatePost(requestParameters.instancesCreatePostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Query all instances of one or all Apps
     * @param {InstancesApiInstancesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesGet(requestParameters: InstancesApiInstancesGetRequest = {}, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesGet(requestParameters.app, requestParameters.version, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all passed through usb devices of an instance
     * @param {InstancesApiInstancesInstanceIdConfigDevicesUsbDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigDevicesUsbDelete(requestParameters: InstancesApiInstancesInstanceIdConfigDevicesUsbDeleteRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigDevicesUsbDelete(requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve passed through usb devices of an instance
     * @param {InstancesApiInstancesInstanceIdConfigDevicesUsbGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigDevicesUsbGet(requestParameters: InstancesApiInstancesInstanceIdConfigDevicesUsbGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigDevicesUsbGet(requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete passed through usb device of the instance with the given port
     * @param {InstancesApiInstancesInstanceIdConfigDevicesUsbPortDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigDevicesUsbPortDelete(requestParameters: InstancesApiInstancesInstanceIdConfigDevicesUsbPortDeleteRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigDevicesUsbPortDelete(requestParameters.instanceId, requestParameters.port, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve passed through usb device of the instance with the given port
     * @param {InstancesApiInstancesInstanceIdConfigDevicesUsbPortGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigDevicesUsbPortGet(requestParameters: InstancesApiInstancesInstanceIdConfigDevicesUsbPortGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigDevicesUsbPortGet(requestParameters.instanceId, requestParameters.port, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pass through usb device with the given port to the instance
     * @param {InstancesApiInstancesInstanceIdConfigDevicesUsbPortPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigDevicesUsbPortPut(requestParameters: InstancesApiInstancesInstanceIdConfigDevicesUsbPortPutRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigDevicesUsbPortPut(requestParameters.instanceId, requestParameters.port, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete environment of an instance
     * @param {InstancesApiInstancesInstanceIdConfigEnvironmentDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigEnvironmentDelete(requestParameters: InstancesApiInstancesInstanceIdConfigEnvironmentDeleteRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigEnvironmentDelete(requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve environment of an instance
     * @param {InstancesApiInstancesInstanceIdConfigEnvironmentGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigEnvironmentGet(requestParameters: InstancesApiInstancesInstanceIdConfigEnvironmentGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigEnvironmentGet(requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Modify or create environment of an instance
     * @param {InstancesApiInstancesInstanceIdConfigEnvironmentPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigEnvironmentPut(requestParameters: InstancesApiInstancesInstanceIdConfigEnvironmentPutRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigEnvironmentPut(requestParameters.instanceId, requestParameters.instanceEnvironmentVariable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an environment variable of an instance
     * @param {InstancesApiInstancesInstanceIdConfigEnvironmentVariableNameDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigEnvironmentVariableNameDelete(requestParameters: InstancesApiInstancesInstanceIdConfigEnvironmentVariableNameDeleteRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigEnvironmentVariableNameDelete(requestParameters.instanceId, requestParameters.variableName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve the value of an environment variable
     * @param {InstancesApiInstancesInstanceIdConfigEnvironmentVariableNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigEnvironmentVariableNameGet(requestParameters: InstancesApiInstancesInstanceIdConfigEnvironmentVariableNameGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigEnvironmentVariableNameGet(requestParameters.instanceId, requestParameters.variableName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set the value of an environment variable of an instance
     * @param {InstancesApiInstancesInstanceIdConfigEnvironmentVariableNamePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigEnvironmentVariableNamePut(requestParameters: InstancesApiInstancesInstanceIdConfigEnvironmentVariableNamePutRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigEnvironmentVariableNamePut(requestParameters.instanceId, requestParameters.variableName, requestParameters.instancesInstanceIdConfigEnvironmentVariableNameGet200Response, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get configuration of an Instance
     * @param {InstancesApiInstancesInstanceIdConfigGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigGet(requestParameters: InstancesApiInstancesInstanceIdConfigGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigGet(requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve labels of an instance
     * @param {InstancesApiInstancesInstanceIdConfigLabelsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigLabelsGet(requestParameters: InstancesApiInstancesInstanceIdConfigLabelsGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigLabelsGet(requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve value of a specific label of an instance
     * @param {InstancesApiInstancesInstanceIdConfigLabelsLabelNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigLabelsLabelNameGet(requestParameters: InstancesApiInstancesInstanceIdConfigLabelsLabelNameGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigLabelsLabelNameGet(requestParameters.instanceId, requestParameters.labelName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve bind mount of an instance
     * @param {InstancesApiInstancesInstanceIdConfigMountsBindContainerPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigMountsBindContainerPathGet(requestParameters: InstancesApiInstancesInstanceIdConfigMountsBindContainerPathGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigMountsBindContainerPathGet(requestParameters.instanceId, requestParameters.containerPath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve bind mounts of an instance
     * @param {InstancesApiInstancesInstanceIdConfigMountsBindGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigMountsBindGet(requestParameters: InstancesApiInstancesInstanceIdConfigMountsBindGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigMountsBindGet(requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve volumes of an instance
     * @param {InstancesApiInstancesInstanceIdConfigMountsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigMountsGet(requestParameters: InstancesApiInstancesInstanceIdConfigMountsGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigMountsGet(requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve volumes mounts of an instance
     * @param {InstancesApiInstancesInstanceIdConfigMountsVolumesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigMountsVolumesGet(requestParameters: InstancesApiInstancesInstanceIdConfigMountsVolumesGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigMountsVolumesGet(requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve volume mount of an instance
     * @param {InstancesApiInstancesInstanceIdConfigMountsVolumesVolumeNameGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigMountsVolumesVolumeNameGet(requestParameters: InstancesApiInstancesInstanceIdConfigMountsVolumesVolumeNameGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigMountsVolumesVolumeNameGet(requestParameters.instanceId, requestParameters.volumeName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve connected networks of instance
     * @param {InstancesApiInstancesInstanceIdConfigNetworksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigNetworksGet(requestParameters: InstancesApiInstancesInstanceIdConfigNetworksGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigNetworksGet(requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove connected network of instance
     * @param {InstancesApiInstancesInstanceIdConfigNetworksNetworkIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigNetworksNetworkIdDelete(requestParameters: InstancesApiInstancesInstanceIdConfigNetworksNetworkIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigNetworksNetworkIdDelete(requestParameters.instanceId, requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve connected network of instance
     * @param {InstancesApiInstancesInstanceIdConfigNetworksNetworkIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigNetworksNetworkIdGet(requestParameters: InstancesApiInstancesInstanceIdConfigNetworksNetworkIdGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigNetworksNetworkIdGet(requestParameters.instanceId, requestParameters.networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Connect instance to network
     * @param {InstancesApiInstancesInstanceIdConfigNetworksPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigNetworksPost(requestParameters: InstancesApiInstancesInstanceIdConfigNetworksPostRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigNetworksPost(requestParameters.instanceId, requestParameters.instancesInstanceIdConfigNetworksPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete exposed ports of an instance
     * @param {InstancesApiInstancesInstanceIdConfigPortsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigPortsDelete(requestParameters: InstancesApiInstancesInstanceIdConfigPortsDeleteRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigPortsDelete(requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve exposed ports of an instance
     * @param {InstancesApiInstancesInstanceIdConfigPortsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigPortsGet(requestParameters: InstancesApiInstancesInstanceIdConfigPortsGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigPortsGet(requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all published ports of an instance for the given transport_protocol
     * @param {InstancesApiInstancesInstanceIdConfigPortsTransportProtocolDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigPortsTransportProtocolDelete(requestParameters: InstancesApiInstancesInstanceIdConfigPortsTransportProtocolDeleteRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigPortsTransportProtocolDelete(requestParameters.instanceId, requestParameters.transportProtocol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get published ports of an instance for the given transport_protocol
     * @param {InstancesApiInstancesInstanceIdConfigPortsTransportProtocolGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigPortsTransportProtocolGet(requestParameters: InstancesApiInstancesInstanceIdConfigPortsTransportProtocolGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigPortsTransportProtocolGet(requestParameters.instanceId, requestParameters.transportProtocol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove instance port range that is mapped to the given host port range
     * @param {InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangeDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigPortsTransportProtocolHostPortRangeDelete(requestParameters: InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangeDeleteRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigPortsTransportProtocolHostPortRangeDelete(requestParameters.instanceId, requestParameters.transportProtocol, requestParameters.hostPortRange, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve instance port range that is mapped to the given host port range
     * @param {InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangeGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigPortsTransportProtocolHostPortRangeGet(requestParameters: InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangeGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigPortsTransportProtocolHostPortRangeGet(requestParameters.instanceId, requestParameters.transportProtocol, requestParameters.hostPortRange, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set instance port range that is mapped to the given host port range
     * @param {InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigPortsTransportProtocolHostPortRangePut(requestParameters: InstancesApiInstancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigPortsTransportProtocolHostPortRangePut(requestParameters.instanceId, requestParameters.transportProtocol, requestParameters.hostPortRange, requestParameters.instancesInstanceIdConfigPortsTransportProtocolHostPortRangePutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update or create published ports of an instance for the given transport protocol
     * @param {InstancesApiInstancesInstanceIdConfigPortsTransportProtocolPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigPortsTransportProtocolPut(requestParameters: InstancesApiInstancesInstanceIdConfigPortsTransportProtocolPutRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigPortsTransportProtocolPut(requestParameters.instanceId, requestParameters.transportProtocol, requestParameters.instancePortMapping, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update configuration of an Instance
     * @param {InstancesApiInstancesInstanceIdConfigPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdConfigPost(requestParameters: InstancesApiInstancesInstanceIdConfigPostRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdConfigPost(requestParameters.instanceId, requestParameters.instanceConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a single instance
     * @param {InstancesApiInstancesInstanceIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdDelete(requestParameters: InstancesApiInstancesInstanceIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdDelete(requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Access an editor of an app
     * @param {InstancesApiInstancesInstanceIdEditorPortGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdEditorPortGet(requestParameters: InstancesApiInstancesInstanceIdEditorPortGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdEditorPortGet(requestParameters.instanceId, requestParameters.port, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Obtain details of an App instance
     * @param {InstancesApiInstancesInstanceIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdGet(requestParameters: InstancesApiInstancesInstanceIdGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdGet(requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve logs of an Instance
     * @param {InstancesApiInstancesInstanceIdLogsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdLogsGet(requestParameters: InstancesApiInstancesInstanceIdLogsGetRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdLogsGet(requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update or downgrade Instance to another App version
     * @param {InstancesApiInstancesInstanceIdPatchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdPatch(requestParameters: InstancesApiInstancesInstanceIdPatchRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdPatch(requestParameters.instanceId, requestParameters.instancesInstanceIdPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start an App instance
     * @param {InstancesApiInstancesInstanceIdStartPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdStartPost(requestParameters: InstancesApiInstancesInstanceIdStartPostRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdStartPost(requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop an App instance
     * @param {InstancesApiInstancesInstanceIdStopPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InstancesApi
     */
    public instancesInstanceIdStopPost(requestParameters: InstancesApiInstancesInstanceIdStopPostRequest, options?: RawAxiosRequestConfig) {
        return InstancesApiFp(this.configuration).instancesInstanceIdStopPost(requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobsApi - axios parameter creator
 * @export
 */
export const JobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieve a list of all pending/queued/running/failed/cancelled jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Cancel job or remove failed/successful/cancelled job from journal
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsJobIdDelete: async (jobId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('jobsJobIdDelete', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve information for specific job_id
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsJobIdGet: async (jobId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('jobsJobIdGet', 'jobId', jobId)
            const localVarPath = `/jobs/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieve a list of all pending/queued/running/failed/cancelled jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Job>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.jobsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Cancel job or remove failed/successful/cancelled job from journal
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsJobIdDelete(jobId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsJobIdDelete(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.jobsJobIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve information for specific job_id
         * @param {number} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jobsJobIdGet(jobId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Job>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.jobsJobIdGet(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.jobsJobIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobsApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieve a list of all pending/queued/running/failed/cancelled jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<Job>> {
            return localVarFp.jobsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Cancel job or remove failed/successful/cancelled job from journal
         * @param {JobsApiJobsJobIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsJobIdDelete(requestParameters: JobsApiJobsJobIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.jobsJobIdDelete(requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve information for specific job_id
         * @param {JobsApiJobsJobIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jobsJobIdGet(requestParameters: JobsApiJobsJobIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Job> {
            return localVarFp.jobsJobIdGet(requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for jobsJobIdDelete operation in JobsApi.
 * @export
 * @interface JobsApiJobsJobIdDeleteRequest
 */
export interface JobsApiJobsJobIdDeleteRequest {
    /**
     * 
     * @type {number}
     * @memberof JobsApiJobsJobIdDelete
     */
    readonly jobId: number
}

/**
 * Request parameters for jobsJobIdGet operation in JobsApi.
 * @export
 * @interface JobsApiJobsJobIdGetRequest
 */
export interface JobsApiJobsJobIdGetRequest {
    /**
     * 
     * @type {number}
     * @memberof JobsApiJobsJobIdGet
     */
    readonly jobId: number
}

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI {
    /**
     * 
     * @summary Retrieve a list of all pending/queued/running/failed/cancelled jobs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public jobsGet(options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Cancel job or remove failed/successful/cancelled job from journal
     * @param {JobsApiJobsJobIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public jobsJobIdDelete(requestParameters: JobsApiJobsJobIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsJobIdDelete(requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve information for specific job_id
     * @param {JobsApiJobsJobIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public jobsJobIdGet(requestParameters: JobsApiJobsJobIdGetRequest, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).jobsJobIdGet(requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get devices of system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemDevicesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/devices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get usb devices of system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemDevicesUsbGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/devices/usb`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get usb device of system
         * @param {string} port 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemDevicesUsbPortGet: async (port: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'port' is not null or undefined
            assertParamExists('systemDevicesUsbPortGet', 'port', port)
            const localVarPath = `/system/devices/usb/{port}`
                .replace(`{${"port"}}`, encodeURIComponent(String(port)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get architecture and operating system information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemInfoGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get network adapters of system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemNetworkAdaptersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/network_adapters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get network adapter of system
         * @param {string} networkAdapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemNetworkAdaptersNetworkAdapterIdGet: async (networkAdapterId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkAdapterId' is not null or undefined
            assertParamExists('systemNetworkAdaptersNetworkAdapterIdGet', 'networkAdapterId', networkAdapterId)
            const localVarPath = `/system/network_adapters/{network_adapter_id}`
                .replace(`{${"network_adapter_id"}}`, encodeURIComponent(String(networkAdapterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check daemon availability and connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPingGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get FLECS core and API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemVersionGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get devices of system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemDevicesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Devices>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemDevicesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.systemDevicesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get usb devices of system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemDevicesUsbGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UsbDevice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemDevicesUsbGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.systemDevicesUsbGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get usb device of system
         * @param {string} port 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemDevicesUsbPortGet(port: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsbDevice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemDevicesUsbPortGet(port, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.systemDevicesUsbPortGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get architecture and operating system information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemInfoGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemInfoGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.systemInfoGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get network adapters of system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemNetworkAdaptersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NetworkAdapter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemNetworkAdaptersGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.systemNetworkAdaptersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get network adapter of system
         * @param {string} networkAdapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemNetworkAdaptersNetworkAdapterIdGet(networkAdapterId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkAdapter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemNetworkAdaptersNetworkAdapterIdGet(networkAdapterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.systemNetworkAdaptersNetworkAdapterIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check daemon availability and connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemPingGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdditionalInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemPingGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.systemPingGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get FLECS core and API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemVersionGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemVersionGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemVersionGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.systemVersionGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * 
         * @summary Get devices of system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemDevicesGet(options?: RawAxiosRequestConfig): AxiosPromise<Devices> {
            return localVarFp.systemDevicesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get usb devices of system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemDevicesUsbGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<UsbDevice>> {
            return localVarFp.systemDevicesUsbGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get usb device of system
         * @param {SystemApiSystemDevicesUsbPortGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemDevicesUsbPortGet(requestParameters: SystemApiSystemDevicesUsbPortGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<UsbDevice> {
            return localVarFp.systemDevicesUsbPortGet(requestParameters.port, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get architecture and operating system information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemInfoGet(options?: RawAxiosRequestConfig): AxiosPromise<SystemInfo> {
            return localVarFp.systemInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get network adapters of system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemNetworkAdaptersGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<NetworkAdapter>> {
            return localVarFp.systemNetworkAdaptersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get network adapter of system
         * @param {SystemApiSystemNetworkAdaptersNetworkAdapterIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemNetworkAdaptersNetworkAdapterIdGet(requestParameters: SystemApiSystemNetworkAdaptersNetworkAdapterIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<NetworkAdapter> {
            return localVarFp.systemNetworkAdaptersNetworkAdapterIdGet(requestParameters.networkAdapterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check daemon availability and connectivity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemPingGet(options?: RawAxiosRequestConfig): AxiosPromise<AdditionalInfo> {
            return localVarFp.systemPingGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get FLECS core and API version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemVersionGet(options?: RawAxiosRequestConfig): AxiosPromise<SystemVersionGet200Response> {
            return localVarFp.systemVersionGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for systemDevicesUsbPortGet operation in SystemApi.
 * @export
 * @interface SystemApiSystemDevicesUsbPortGetRequest
 */
export interface SystemApiSystemDevicesUsbPortGetRequest {
    /**
     * 
     * @type {string}
     * @memberof SystemApiSystemDevicesUsbPortGet
     */
    readonly port: string
}

/**
 * Request parameters for systemNetworkAdaptersNetworkAdapterIdGet operation in SystemApi.
 * @export
 * @interface SystemApiSystemNetworkAdaptersNetworkAdapterIdGetRequest
 */
export interface SystemApiSystemNetworkAdaptersNetworkAdapterIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof SystemApiSystemNetworkAdaptersNetworkAdapterIdGet
     */
    readonly networkAdapterId: string
}

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * 
     * @summary Get devices of system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemDevicesGet(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemDevicesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get usb devices of system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemDevicesUsbGet(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemDevicesUsbGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get usb device of system
     * @param {SystemApiSystemDevicesUsbPortGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemDevicesUsbPortGet(requestParameters: SystemApiSystemDevicesUsbPortGetRequest, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemDevicesUsbPortGet(requestParameters.port, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get architecture and operating system information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemInfoGet(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get network adapters of system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemNetworkAdaptersGet(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemNetworkAdaptersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get network adapter of system
     * @param {SystemApiSystemNetworkAdaptersNetworkAdapterIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemNetworkAdaptersNetworkAdapterIdGet(requestParameters: SystemApiSystemNetworkAdaptersNetworkAdapterIdGetRequest, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemNetworkAdaptersNetworkAdapterIdGet(requestParameters.networkAdapterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check daemon availability and connectivity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemPingGet(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemPingGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get FLECS core and API version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemVersionGet(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemVersionGet(options).then((request) => request(this.axios, this.basePath));
    }
}



